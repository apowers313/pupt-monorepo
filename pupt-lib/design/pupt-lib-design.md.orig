# pupt-lib Design Document

A TypeScript library that enables programmatic, composable, OOP-empowered AI prompt creation using JSX.

---

## Table of Contents

### Quick Reference

| Topic | Section | Key Info |
|-------|---------|----------|
| How components are defined | [Component Interface](#component-interface) | Class extends `Component<Props>`, auto-discovered |
| How components are resolved | [Component Resolution](#component-resolution-option-b-string-based-registry-lookup) | String-based lookup, no imports needed |
| Declaring dependencies | [Uses Component](#uses-component) | `<Uses src="@pkg" />` declares module dependencies |
| Loading libraries | [Module Loading API](#module-loading-api) | `Pupt` class for CLI and browser |
| Main API entry point | [Pupt Class](#pupt-class) | `new Pupt({ modules: [...] })` |
| Namespace conflicts | [Conflict Resolution](#conflict-resolution-scope-component) | Use `<Scope from="pkg">` wrapper |
| Simple prompt files | [Simple Prompt Format](#simple-prompt-format) | `.prompt` files with runtime parsing |
| User input collection | [Input Iterator](#input-iterator-interface) | `start()` / `current()` / `submit()` / `advance()` |
| User input syntax | [Ask.* Components](#user-input-components-ask) | Child elements (simple) or JS attributes (advanced) |
| Conditional rendering | [Control Flow Components](#control-flow-components) | Excel formula syntax: `<If when='=count>5'>` |
| Conditional input access | [Condition Input Access](#condition-input-access-proxy-wrapped-object) | Use `inputs.userType` (not `inputs.get()`) |
| Input validation | [Input Validation](#input-validation-async-with-explicit-control-flow) | Async validation, custom validators, retry loop |
| Non-interactive mode | [Non-Interactive Mode](#non-interactive-mode) | `InputIteratorOptions.nonInteractive` |
| Post-execution actions | [Post-Execution Components](#post-execution-components) | `<PostExecution>`, ReviewFile, OpenUrl, RunCommand |
| Render result type | [RenderResult](#core-functions) | `{ text, postExecution[] }` |
| Environment/LLM config | [Environment Context](#environment-context) | Target LLM, output format, runtime values |
| Built-in components | [Default Component Library](#default-component-library) | Role, Task, Context, Ask.*, etc. |
| Third-party libraries | [Library Loading](#third-party-library-loading) | Export Component subclasses, auto-discovered |
| Module author workflow | [Module Author Workflow](#module-author-workflow) | How to publish components |
| Prompt author workflow | [Prompt Author Workflow](#prompt-author-workflow) | How to publish simple prompts |
| Browser support | [Browser Module Loading](#browser-module-loading) | Import maps + deduplication |
| JSX transformation | [Runtime JSX](#runtime-jsx-transformation) | Babel config, custom runtime |

### Full Table of Contents

1. **[Project Overview](#project-overview)** - Library purpose, design goals, and value proposition
   - [Why pupt-lib?](#why-pupt-lib) - The problem we're solving
   - [Design Goals](#design-goals) - File-based, composable, shareable, automation-ready
   - [Features](#features) - Core authoring, ecosystem, flexibility
   - [Non-Goals](#non-goals) - What the library doesn't do
   - [Target Users](#target-users) - Prompt authors, tool builders, teams

2. **[Design Decisions](#design-decisions)** - Architectural choices with rationale and alternatives
   - [Component Resolution: Option B](#component-resolution-option-b-string-based-registry-lookup) - String-based registry lookup (no imports)
   - [Library-Based Scoping](#library-based-scoping) - Scope derived from library metadata
   - [Local Prompts: Combined Scope](#local-prompts-combined-scope) - Local prompts access all loaded components
   - [Conflict Resolution: `<Scope>`](#conflict-resolution-scope-component) - Wrapper to disambiguate component names
   - [Third-Party Library Detection](#third-party-library-detection) - Export scanning for Component subclasses
   - [Component Export Convention](#component-export-convention) - Export Component subclasses as named exports
   - [Environment Context API Stability](#environment-context-api-stability-future-work) - Proxy-based access (future work)
   - [Conditional Input Collection](#conditional-input-collection-depth-first-generator) - Depth-first generator approach
   - [Condition Input Access](#condition-input-access-proxy-wrapped-object) - Proxy for natural `inputs.userType` syntax
   - [Input Validation](#input-validation-async-with-explicit-control-flow) - Async validation with current/submit/advance API
   - [Component Model](#component-model-class-based-with-inheritance) - Class-based with `Component<Props>` inheritance
   - [Conditional Syntax](#conditional-syntax-excel-formulas) - Excel formulas for non-technical users
   - [User Input Syntax](#user-input-syntax-child-elements--js-attributes) - Child elements (simple) + JS attributes (advanced)
   - [Module Loading](#module-loading-url-based-with-auto-discovery) - URL, npm, and local paths with auto-discovery
   - [Dependency Declaration](#dependency-declaration-uses-component) - `<Uses>` component for portable prompts
     - [No YAML Frontmatter](#sub-decision-no-yaml-frontmatter) - Use Prompt attributes instead
     - [Uses Placement](#sub-decision-uses-placement-outside-prompt) - Outside Prompt at file level
     - [Single src Attribute](#sub-decision-single-src-attribute-for-all-formats) - One attribute for all formats
     - [Optional with Helpful Errors](#sub-decision-optional-dependencies-with-helpful-errors) - Best DX approach
   - [Unified Module Loading](#unified-module-loading-pupt-class) - `Pupt` class for CLI and browser
     - [Browser Import Maps](#sub-decision-browser-module-loading-via-import-maps) - Auto-generated for deduplication
     - [Module Deduplication](#sub-decision-module-deduplication-strategy) - Tracking loaded modules
     - [Capability Declarations](#sub-decision-environment-capability-declarations) - Filesystem, network warnings

3. **[Scaffolding Tools](#scaffolding-tools)** - Build, test, and development tools
   - [Build & Development](#build--development) - Vite, TypeScript, tsup
   - [Testing](#testing) - Vitest configuration
   - [Linting & Code Quality](#linting--code-quality) - ESLint, Prettier
   - [Git Hooks & Commits](#git-hooks--commits) - Husky, commitlint
   - [Release & CI/CD](#release--cicd) - Semantic release
   - [JSX Transformation](#jsx-transformation) - Babel configuration

4. **[Architecture](#architecture)** - System design and data flow
   - [High-Level Architecture](#high-level-architecture) - Component diagram
   - [Data Flow](#data-flow) - JSX → Inputs → Text transformation

5. **[JSX Component System](#jsx-component-system)** - Custom JSX runtime and components
   - [Custom JSX Runtime](#custom-jsx-runtime) - `jsx()`, `jsxs()`, `Fragment` functions
   - [Component Interface](#component-interface) - Class-based `Component<Props>` with auto-discovery
   - [Environment Context](#environment-context) - LLM targeting, output format, runtime values
     - [Default Environment](#default-environment) - Default configuration values
     - [Component Usage of Environment](#component-usage-of-environment) - Accessing context in components
     - [LLM-Specific Optimization Guidelines](#llm-specific-optimization-guidelines) - Claude, GPT, Gemini optimizations

6. **[User Input Abstraction](#user-input-abstraction)** - Collecting user input from prompts
   - [Design Philosophy](#design-philosophy) - UI-agnostic input collection
   - [Input Component Types](#input-component-types) - Ask.Text, Ask.Select, Ask.Confirm, etc.
   - [Input Collection Interface](#input-collection-interface)
     - [Why Depth-First?](#why-depth-first) - Order guarantees for conditional inputs
     - [Input Requirement Interface](#input-requirement-interface) - `InputRequirement` type with validation
     - [Input Iterator Interface](#input-iterator-interface) - `start/current/submit/advance` API
     - [Non-Interactive Mode](#non-interactive-mode) - Automation and CI/CD support
     - [Pre-Supplied Values](#pre-supplied-values) - Skip known inputs
     - [Iterator Implementation Notes](#iterator-implementation-notes) - Full implementation with async validation
     - [Input Collector (Convenience Wrapper)](#input-collector-convenience-wrapper) - Higher-level API with retry
   - [Example Usage by Higher-Level Program](#example-usage-by-higher-level-program) - CLI example
   - [Advanced: Manual Iterator Control](#advanced-manual-iterator-control) - Progress display, custom retry
   - [React/Web UI Example](#reactweb-ui-example) - Component persistence on validation failure

7. **[Third-Party Library Loading](#third-party-library-loading)** - Loading component libraries
   - [Library Resolution](#library-resolution) - How packages are discovered

8. **[Component Registry](#component-registry)** - Component storage and lookup
   - [Registry Interface](#registry-interface) - `ComponentRegistry` API
   - [Default Registry](#default-registry) - Built-in component registration
   - [Registry Implementation](#registry-implementation) - Detailed implementation
   - [Usage Examples](#usage-examples) - Registration, third-party, testing

9. **[Scope and Scope Loading](#scope-and-scope-loading)** - Package-based scoping system
   - [Scope Class](#scope-class) - Scope API and implementation
   - [ScopeLoader Class](#scopeloader-class) - Walking package.json dependencies
   - [How ScopeLoader Works](#how-scopeloader-works) - Dependency tree traversal
   - [Edge Case Handling](#edge-case-handling) - Circular deps, diamond deps, monorepos
   - [Detecting pupt-lib Libraries](#detecting-pupt-lib-libraries) - peerDependencies convention

10. **[Third-Party Library Loading](#third-party-library-loading-1)** - Package structure for libraries
    - [Library Package Structure](#library-package-structure) - How to create a component library

11. **[Simple Prompt Format](#simple-prompt-format)** - `.prompt` files for non-technical users
    - [File Format](#file-format) - XML-like syntax
    - [Runtime Parsing](#runtime-parsing) - No build step required
    - [Variable Interpolation](#variable-interpolation) - Basic `{inputs.name}` syntax

12. **[Module Author Workflow](#module-author-workflow)** - Publishing component libraries
    - Project structure, package.json, implementation, build & publish

13. **[Prompt Author Workflow](#prompt-author-workflow)** - Publishing prompts
    - Single file, package of prompts, advanced TypeScript prompts

14. **[Prompt Search](#prompt-search)** - Fuzzy search and filtering
    - [Searchable Prompt Interface](#searchable-prompt-interface) - Indexable fields
    - [Search Options](#search-options) - Query, tags, limit, offset
    - [Search Engine Interface](#search-engine-interface) - Fuse.js-based implementation
    - [Search Engine Configuration](#search-engine-configuration) - Weights, thresholds
    - [Implementation Notes](#implementation-notes) - Scoring, caching, indexing
    - [Usage Examples](#usage-examples-1) - Basic search, interactive, tag browsing

15. **[Runtime JSX Transformation](#runtime-jsx-transformation)** - Babel-based JSX processing
    - [Babel Configuration](#babel-configuration) - Transform settings
    - [Babel Preset Configuration](#babel-preset-configuration) - Preset options

16. **[Prompt Best Practices Integration](#prompt-best-practices-integration)** - Research-backed patterns
    - [Research-Backed Practices](#research-backed-practices)
      - Clear Structure, XML-Style Tags, Few-Shot Examples
      - Step-by-Step Reasoning, Success Criteria
      - Positive Framing, Output Format Specification

17. **[Default Component Library](#default-component-library)** - Built-in components
    - [Prompt Container Component](#prompt-container-component) - Top-level `<Prompt>` wrapper
      - [Prompt Props Interface](#prompt-props-interface)
      - [Prompt vs Fragment](#prompt-vs-fragment) - When to use each
      - [Checking if Element is a Prompt](#checking-if-element-is-a-prompt)
    - [Core Structural Components](#core-structural-components) - Role, Task, Context, Constraints, etc.
    - [Example Components](#example-components) - Example, Examples, FewShot
    - [Reasoning Components](#reasoning-components) - ChainOfThought, StepByStep
    - [Data Components](#data-components) - Data, Json, Xml
    - [Utility Components](#utility-components) - UUID, Timestamp, DateTime, Hostname, etc.
      - [Usage in Prompts](#usage-in-prompts)
      - [Accessing Runtime Values](#accessing-runtime-values-in-components)
    - [Control Flow Components](#control-flow-components) - If (Excel formulas), ForEach
    - [Uses Component](#uses-component) - Declare module dependencies
      - [Uses Props Interface](#uses-props-interface)
      - [Source Formats](#source-formats)
      - [Uses Behavior](#uses-behavior)
      - [When Uses is Optional](#when-uses-is-optional)
    - [Scope Resolution Components](#scope-resolution-components) - `<Scope>` wrapper
      - [Scope Props Interface](#scope-props-interface)
      - [Scope Implementation](#scope-implementation)
      - [When to Use Scope](#when-to-use-scope)
    - [Post-Execution Components](#post-execution-components) - Actions after prompt execution
      - [PostExecution Container](#postexecution-container) - Wrapper for action components
      - [Action Components](#action-components) - ReviewFile, OpenUrl, RunCommand
      - [PostExecution Implementation](#postexecution-implementation)
      - [RenderContext Update](#rendercontext-update)
      - [CLI Usage Example](#cli-usage-example)
    - [User Input Components (Ask.*)](#user-input-components-ask) - Ask.Text, Ask.Select, Ask.ReviewFile, etc.

18. **[API Design](#api-design)** - Public API surface
    - [API Summary](#api-summary) - Comprehensive table of all exports
    - [Main Exports](#main-exports) - What the library exports
    - [Module Loading API](#module-loading-api) - Pupt class for CLI and browser
      - [Pupt Class](#pupt-class) - Main entry point
      - [Pupt Configuration](#pupt-configuration) - Options and setup
      - [Source Format Resolution](#source-format-resolution) - npm, URL, git, local
      - [Module Deduplication](#module-deduplication) - Preventing duplicate loads
      - [Browser Module Loading](#browser-module-loading) - Import maps
    - [Core Functions](#core-functions) - `render()`, `collectInputs()`, etc.

19. **[File Structure](#file-structure)** - Source code organization

20. **[Configuration Files](#configuration-files)** - Project configuration
    - package.json, tsconfig.json, vite.config.ts, vitest.config.ts
    - eslint.config.mjs, knip.json, commitlint.config.js
    - .releaserc, .github/workflows/ci.yml, .gitignore, Husky Hooks

21. **[Usage Examples](#usage-examples-2)** - Code examples
    - [Environment Configuration](#environment-configuration)
    - [Basic Prompt](#basic-prompt)
    - [Rendered Output](#rendered-output)
    - [Using the Library](#using-the-library)
    - [Pre-Supplied Values](#pre-supplied-values-skip-user-input)

22. **[Research References](#research-references)** - Source materials
    - Prompt Engineering Guides, Academic Papers, Related Libraries

23. **[Browser Compatibility](#browser-compatibility)** - Running in browsers
    - Import maps, CDN fallback, build-time bundling

24. **[Implementation Notes](#implementation-notes-1)** - Development priorities
    - [Priority Order](#priority-order) - Phase 1, 2, 3
    - [Component Research Basis](#component-research-basis)
    - [Testing Strategy](#testing-strategy)
    - [Documentation](#documentation)

25. **[Future Work](#future-work)** - Planned features
    - Production Quality Components, Advanced Structural Components
    - Advanced Reasoning Components, Framework Composite Components

26. **[Resolved Design Issues](#resolved-design-issues)** - Previously open, now resolved
    - [Browser Module Loading](#browser-module-loading) - Import maps + auto-generation
    - [Library Dependency Resolution](#library-dependency-resolution) - Loader handles order
    - [Component Detection Across Bundles](#component-detection-across-bundles) - Global Symbol

---

## Project Overview

**pupt-lib** is a TypeScript library for creating AI prompts as versionable, composable, shareable files using JSX syntax.

### Why pupt-lib?

Prompts are becoming critical software artifacts, yet most are written inline, copy-pasted between projects, and lost when chat sessions end. pupt-lib treats prompts as first-class code:

- **Version controlled** — Prompts live in files, tracked in git, reviewed in PRs
- **Composable** — Build complex prompts from reusable components
- **Shareable** — Publish prompt libraries to npm, consume others' work
- **Mature over time** — Iterate on prompts like any other code artifact

**Why JSX?** JSX provides the best of both worlds:
- Simple prompts look like HTML—accessible to non-developers
- Complex prompts have full TypeScript power—loops, conditionals, type safety
- This pattern has proven successful: AWS CDK over CloudFormation, React over string templates, Gulp over Grunt

### Design Goals

| Goal | Description |
|------|-------------|
| **File-Based Prompts** | Prompts are `.tsx` files that can be version controlled, diffed, and improved over time |
| **Code Over Templates** | Uses TypeScript/JSX rather than text templates (Handlebars, Mustache). Code-based approaches consistently win: AWS CDK over CloudFormation, Gulp over Grunt, React over string templating. Full programming language power when you need it. |
| **Accessible to Non-Developers** | Simple prompts look like HTML—just markup with no code required. Non-technical users can author prompts without learning TypeScript. Complexity is opt-in. |
| **Composability** | Build complex prompts from reusable pieces using JSX component model |
| **Shareability** | Publish and consume prompt libraries via npm, URLs, or local files |
| **Clean Syntax** | Prompt files are readable with no boilerplate imports required |
| **UI Agnostic** | Library handles prompt logic; any UI (CLI, web, desktop) can collect inputs |
| **LLM Agnostic** | Target Claude, GPT, Gemini, or others with environment-based output optimization |
| **Research-Backed** | Built-in components encode prompt engineering best practices |
| **Automation-Ready** | Non-interactive mode and pre-supplied values for CI/CD pipelines |

### Features

**Core Prompt Authoring:**
- JSX syntax for prompts (familiar to React/TypeScript developers)
- Built-in structural components: `<Role>`, `<Task>`, `<Context>`, `<Constraints>`, `<Examples>`
- User input components: `<Ask.Text>`, `<Ask.Select>`, `<Ask.File>`, `<Ask.Confirm>`
- Conditional rendering with `<If>` and `<Conditional>`
- Utility components: `<UUID>`, `<Timestamp>`, `<Hostname>`, `<Username>`

**Ecosystem & Sharing:**
- Third-party prompt libraries loadable via npm, URLs, or local paths
- Library-based scoping prevents namespace conflicts
- `<Scope>` component for explicit disambiguation when needed
- Fuzzy search and tag-based discovery across prompt libraries

**Flexibility & Integration:**
- Environment context for LLM-specific output optimization
- Post-execution actions: `<ReviewFile>`, `<OpenUrl>`, `<RunCommand>`
- Non-interactive mode for automation and CI/CD
- Pre-supplied values to skip known inputs programmatically

### Non-Goals

- This library does NOT render UI for collecting user input
- This library does NOT send prompts to LLMs
- This library does NOT handle system prompts

### Target Users

- **Prompt authors** — Write, version, and share reusable prompts
- **Tool builders** — Build CLIs, IDEs, or web apps that use prompts from pupt-lib
- **Teams** — Maintain shared prompt libraries with code review and versioning

---

## Design Decisions

This section documents key architectural decisions, the alternatives considered, and the rationale for each choice.

### Component Resolution: Option B (String-Based Registry Lookup)

**Decision:** Components are resolved by string name from a scoped registry at runtime. Prompt files do not need to import components.

```tsx
// No imports needed - components resolved from registry
export default (
  <Prompt name="support">
    <Role>You are a support agent</Role>
    <Task>Help the customer</Task>
  </Prompt>
);
```

**Alternatives Considered:**

| Option | Description | Pros | Cons |
|--------|-------------|------|------|
| **Option A: Explicit Imports** | Standard JSX - import components to use them | Type-safe, familiar, no namespace conflicts | Verbose prompt files, boilerplate |
| **Option B: String-Based Lookup** | Components resolved by name from registry | Clean prompt files, no imports | Namespace conflicts, no static type checking |
| **Hybrid: Lowercase Built-ins** | Lowercase = string lookup, uppercase = import | Best of both | Two mental models, inconsistent |

**Why Option B:**
- Prompts should be clean and readable - they're the primary artifact users create
- Third-party libraries benefit from clean prompt syntax
- Namespace conflicts are solvable with scoping (see below)
- Type checking can be provided by editor plugins or build-time validation

---

### Library-Based Scoping

**Decision:** Each library gets its own component scope based on its metadata name. Components from a library are registered under that library's scope. Prompts from a library render with access to their own components plus dependencies.

```typescript
// Library defines its scope via metadata
export default {
  name: 'acme-prompts',  // This becomes the scope name
  version: '1.0.0',
  dependencies: ['@common/utils'],  // Dependencies are loaded first
};
```

**Scoping in practice:**

```
acme-prompts (loaded from URL or npm)
├── scope: "acme-prompts"
└── components available: builtins + @common/utils + own components

corp-prompts (loaded from URL or npm)
├── scope: "corp-prompts"
└── components available: builtins + own components
```

**Alternatives Considered:**

| Option | Description | Pros | Cons |
|--------|-------------|------|------|
| **Global Flat Registry** | All components in one namespace | Simple | Namespace conflicts inevitable |
| **Package.json Walking** | Derive scope from npm dependencies | Automatic | Only works for npm, not URLs |
| **Metadata-Based** | Library declares its name and dependencies | Works for URLs and npm | Requires metadata export |

**Why Metadata-Based Scoping:**
- Works for all source types: URLs, npm packages, local files
- Library author controls their scope name
- Dependencies are explicit in the library's metadata
- Conflicts resolved with `<Scope>` wrapper or `as` alias at load time

**Edge Cases Handled:**
- **Circular dependencies:** Detected via "loading" set, return partial scope
- **Name conflicts:** Use `<Scope from="lib-name">` to disambiguate
- **Missing metadata:** Scope name derived from source URL or package name

---

### Local Prompts: Combined Scope

**Decision:** Local prompts (user's own, not from npm packages) get access to all registered components from all loaded packages.

```typescript
const pupt = new Pupt({
  modules: [
    '@acme/prompts',    // Package prompts use @acme's scope
    '@corp/prompts',    // Package prompts use @corp's scope
    './my-prompts',     // Local prompts get combined scope
  ],
});
await pupt.init();
const prompts = pupt.getPrompts();
```

**Rationale:**
- Local prompts are the user's own - they should access whatever they've loaded
- User explicitly configured which libraries to load
- If conflicts occur, user can resolve with `<Scope>` wrapper

---

### Conflict Resolution: `<Scope>` Component

**Decision:** When component names conflict between packages, use the `<Scope>` wrapper to specify which package to resolve from.

```tsx
<Prompt name="my-prompt">
  <Role>...</Role>  {/* Built-in */}

  <Scope from="@acme/prompts">
    <Header>Acme header</Header>     {/* @acme/prompts:Header */}
    <Footer>Acme footer</Footer>     {/* @acme/prompts:Footer */}
  </Scope>

  <Widget scope="@corp/utils" />     {/* One-off: scope prop */}
</Prompt>
```

**Alternatives Considered:**

| Option | Description | Pros | Cons |
|--------|-------------|------|------|
| **Namespace Syntax** | `<acme$prompts:Header>` | Always explicit | Ugly syntax |
| **Config-Based Aliasing** | Rename at load time | User control | Breaks third-party cross-references |
| **`<Scope>` Wrapper** | Wrap children to set resolution scope | Clean, explicit when needed | Slight verbosity |
| **`scope` Prop** | Per-component `scope="@pkg"` | Fine-grained | Very verbose if many components |

**Why `<Scope>` + `scope` prop:**
- Only needed when conflicts exist (most prompts won't need it)
- `<Scope>` for groups, `scope` prop for one-offs
- Full package names are valid (`@acme/prompts`) - no encoding needed
- Explicit is better than implicit when disambiguation is required

**Namespace Syntax Rejected Because:**
- `<@acme/prompts:Header>` is invalid JSX (`@` and `/` not allowed in tag names)
- `<acme$prompts:Header>` works but is ugly
- Only `$` and uppercase differentiate JSX from npm (limited options)
- `<Scope>` achieves the same goal with cleaner syntax

---

### Third-Party Library Detection

**Decision:** Libraries are identified by scanning their exports when loaded via `loadModule()`. Any export that extends the `Component` base class is registered as a component. Any export that is a `<Prompt>` element is registered as a prompt.

**Detection logic:**
- **Components:** Named exports where `value.prototype instanceof Component`
- **Prompts:** Named exports where `value.type === Prompt` (JSX element check)
- **Metadata:** Default export with `{ name, version, dependencies }` (optional)

```typescript
// Module loader scans exports
for (const [exportName, exportValue] of Object.entries(module)) {
  if (isComponentClass(exportValue)) {
    // Register as component using export name
    components[exportName] = exportValue;
  } else if (isPromptElement(exportValue)) {
    // Register as prompt
    prompts[exportName] = exportValue;
  }
}
```

**Alternatives Considered:**

| Option | Description | Pros | Cons |
|--------|-------------|------|------|
| **peerDependencies marker** | Check package.json for pupt-lib | Clear intent | Requires npm package, doesn't work for URLs |
| **Export scanning** | Check exports for Component subclasses | Works for URLs and npm, automatic | Slight runtime cost |
| **Explicit registration** | Require `registerComponent()` calls | Very explicit | Boilerplate, easy to forget |

**Why Export Scanning:**
- Works for all source types: URLs, npm packages, local files
- Zero boilerplate for library authors—just export your classes
- Automatic discovery matches the "just works" philosophy
- Component name comes from export name (no separate `name` property needed)

---

### Component Export Convention

**Decision:** Libraries export Component subclasses as named exports. Components are auto-discovered by the module loader—no explicit registration or `components` array needed.

```typescript
// @acme/prompts/src/index.ts
import { Component } from 'pupt-lib';

// Just export Component subclasses - they're auto-discovered
export class AcmeHeader extends Component<{ title: string }> {
  render({ title }) {
    return `=== ${title} ===`;
  }
}

export class AcmeFooter extends Component {
  render() {
    return '--- ACME Corp ---';
  }
}

// Optional: metadata as default export
export default {
  name: 'acme-prompts',
  version: '1.0.0',
};
```

**Rationale:**
- Zero boilerplate—just extend Component and export
- Component name is the export name (e.g., `AcmeHeader`)
- Library controls what's public via what they export
- No separate `name` property or registration call needed

---

### Environment Context API Stability (Future Work)

**Problem:** The `EnvironmentContext` will be baked into many prompts via `context.env`. Once prompts depend on properties like `context.env.runtime.hostname`, changing the API breaks existing prompts. However, it's too early to freeze the API - we're still learning what fields are needed.

**Decision:** Use a **proxy-based accessor pattern** (future work) that provides clean property access syntax while allowing internal changes without breaking prompts.

```typescript
// Clean property access syntax (what prompt authors write)
context.env.runtime.hostname

// Internally uses accessor (can change implementation anytime)
// Old names can be aliased to new implementations
```

**Alternatives Considered:**

| Option | Description | Pros | Cons |
|--------|-------------|------|------|
| **Versioned Namespaces** | `context.env.v1.runtime`, `context.env.v2.runtime` | Explicit versioning | Complexity, maintain forever |
| **Stable Core + Extensions** | Freeze core, put new things in `extensions` | Clear contract | Too early to know what's "core" |
| **Accessor Functions** | `context.get("hostname")` | Flexible implementation | Loses type safety, no autocomplete, typos fail silently |
| **Frozen Types + Adapter** | Never change public interface | Clean API | Can't fix naming mistakes |
| **Proxy-Based Access** | Property syntax backed by accessor | Best DX, flexible | Slight runtime overhead |

**Why Proxy-Based:**
- **Transparent to users** - Prompts use clean property access: `context.env.runtime.hostname`
- **Flexible internally** - Can rename, refactor, or alias without breaking prompts
- **Type-safe** - TypeScript still provides autocomplete and type checking
- **Discoverable** - IDE shows available properties
- **Backwards compatible** - Old property names can alias to new implementations

**Example of Non-Breaking Rename:**

```typescript
// If we later decide to rename "hostname" to "hostName":
const runtimeProxy = new Proxy({}, {
  get(target, prop) {
    if (prop === "hostname") return os.hostname();  // Old name works
    if (prop === "hostName") return os.hostname();  // New name works
    // ...
  }
});
```

**Implementation Status:** Future work. Initial implementation will use plain objects. Proxy layer will be added before v1.0.0 to ensure API stability.

---

### Conditional Input Collection: Depth-First Generator

**Decision:** Use an async generator that walks the component tree depth-first, yielding questions as they're encountered and receiving answers via `next(answer)`. This allows conditional inputs to be evaluated with previously-collected values.

```typescript
const iterator = inputIterator.iterate(element);
let result = await iterator.next();

while (!result.done) {
  const question = result.value;
  const answer = await askUser(question);
  result = await iterator.next(answer);
}
```

**The Problem:** Prompts can have conditional questions:

```tsx
<Ask.Select name="userType" options={[...]} />
<Conditional when={inputs.userType === "admin"}>
  <Ask.Text name="adminCode" />  {/* Only ask if admin */}
</Conditional>
```

We need to ask `userType` first, evaluate the condition, then maybe ask `adminCode`.

**Alternatives Considered:**

| Option | Description | Pros | Cons |
|--------|-------------|------|------|
| **Multi-Pass** | Get answerable questions, collect answers, repeat | Simple concept | Breadth-first ordering, disjointed UX |
| **Declarative Conditions** | `showWhen={{ field: "x", equals: "y" }}` | All questions known upfront | Limited expressiveness, no JS conditions |
| **Generator (Depth-First)** | Yield questions as encountered, receive answers | Natural ordering, full JS conditions | Can't show total question count |
| **Reactive/Observable** | Questions update as values change | Real-time, flexible | Complex, overkill for CLI |

**Why Generator:**

1. **Depth-first ordering** - Questions near each other in the tree are asked together:
   ```
   Multi-pass would ask: name → email → projectName → (jump back to) adminCode
   Generator asks:       name → adminCode → email → projectName
   ```

2. **Handles any condition** - Full JavaScript expressions, not limited DSL:
   ```tsx
   <Conditional when={inputs.items?.length > 5 && inputs.userType === "admin"}>
   ```

3. **Natural flow** - Single pass through tree, pause at each question, continue with answer

4. **Memory efficient** - No repeated tree walks

**Tradeoff Accepted:**
- Cannot show total question count or progress bar upfront
- This is acceptable because the alternative (disjointed question ordering) is worse UX

---

### Condition Input Access: Proxy-Wrapped Object

**Decision:** Condition functions receive a Proxy-wrapped object that allows natural property access (`inputs.userType`) while maintaining Map-like behavior internally.

```tsx
// This works naturally - no .get() required
<Conditional when={inputs.userType === "admin"}>
  <Ask.Text name="adminCode" />
</Conditional>

// Complex conditions also work
<Conditional when={inputs.items?.length > 5 && inputs.userType === "admin"}>
  <Ask.Text name="specialCode" />
</Conditional>
```

**The Problem:** If `inputs` is a `Map<string, unknown>`, property access silently fails:

```tsx
// Map doesn't have a .userType property - this is always undefined!
<Conditional when={inputs.userType === "admin"}>  // ❌ Always false
```

Users must use `inputs.get("userType")` which is verbose and easy to forget.

**Alternatives Considered:**

| Option | Description | Pros | Cons |
|--------|-------------|------|------|
| **Document `.get()` syntax** | Require `inputs.get("userType")` | No code changes | Verbose, error-prone, silent failures |
| **Use `Record<string, unknown>`** | Plain object instead of Map | Natural property access | Loses Map benefits, mutable |
| **Proxy wrapper** | Proxy that makes Map look like object | Natural syntax, Map internals | Slight complexity |

**Why Proxy:**

1. **Natural syntax** - Users write `inputs.userType` as expected
2. **Silent failure prevention** - No undefined property access issues
3. **Type-safe** - TypeScript can type the proxy appropriately
4. **Backwards compatible** - Still works with `.get()` if someone prefers it

**Implementation:**

```typescript
function createInputsProxy(values: Map<string, unknown>): Record<string, unknown> {
  return new Proxy({} as Record<string, unknown>, {
    get(_, prop: string) {
      return values.get(prop);
    },
    has(_, prop: string) {
      return values.has(prop);
    },
    ownKeys() {
      return Array.from(values.keys());
    },
    getOwnPropertyDescriptor(_, prop: string) {
      if (values.has(prop)) {
        return { configurable: true, enumerable: true, value: values.get(prop) };
      }
      return undefined;
    },
  });
}

// In evaluateCondition:
private evaluateCondition(
  condition: ((inputs: Record<string, unknown>) => boolean) | boolean,
  values: Map<string, unknown>
): boolean {
  if (typeof condition === "function") {
    const proxy = createInputsProxy(values);
    return condition(proxy);
  }
  return Boolean(condition);
}
```

**Type Definition:**

```typescript
// Condition callback receives typed proxy, not Map
type ConditionFn = (inputs: Record<string, unknown>) => boolean;

// Or with stricter typing if input names are known:
type ConditionFn<T extends Record<string, unknown>> = (inputs: T) => boolean;
```

---

### Input Validation: Async with Explicit Control Flow

**Decision:** Validation is async (supporting network calls, file system checks, etc.) and uses an explicit `current()` / `submit()` / `advance()` API rather than re-yielding requirements through the generator.

```typescript
const iterator = createInputIterator(options);
let req = await iterator.start(element);

while (req) {
  let result: ValidationResult;
  do {
    const answer = await askUser(req, result?.error);
    result = await iterator.submit(answer);
  } while (!result.valid);

  req = await iterator.advance();
}
```

**The Problem:** Validation can be complex and asynchronous:
- Check if a file exists on disk
- Verify a hostname resolves via DNS
- Check if a server is reachable
- Validate against an external API

Additionally, when validation fails:
- The UI needs to show an error and let the user retry
- The same input field should remain rendered (not be destroyed/recreated)
- Conditionals should NOT be evaluated with invalid data

**Alternatives Considered:**

| Option | Description | Pros | Cons |
|--------|-------------|------|------|
| **Batch validation at end** | Collect all answers, validate once before render | Simple | No immediate feedback, invalid data may affect conditionals |
| **Pass validate function to caller** | Include `validate: (v) => Promise<Result>` in requirement | Flexible | Can't serialize functions, validation logic leaks to UI layer |
| **Re-yield on validation failure** | Generator yields same requirement with error | Keeps generator pattern | UI can't tell if same question, may re-render input |
| **Explicit current/submit/advance** | Separate methods for getting requirement, validating, and advancing | Clear control flow, UI stability | More verbose API |

**Why Explicit Control Flow:**

1. **UI stability** - `current()` returns the same object until `advance()` is called. UI knows it's the same question and can update error state without re-rendering the input:
   ```tsx
   // React: same key means same component instance
   <Input key={currentReq.name} error={error} />
   ```

2. **Validation stays in pupt-lib** - Validation logic is defined in Ask components, not passed to the caller. The caller just submits values and receives results.

3. **Conditionals only see valid data** - `advance()` only proceeds after `submit()` succeeds, so conditional evaluation always uses validated answers.

4. **Async-friendly** - `submit()` returns a Promise, naturally supporting network calls:
   ```typescript
   // Inside Ask.File component's validator
   validate: async (path) => {
     const exists = await fs.access(path).then(() => true).catch(() => false);
     return exists ? { valid: true } : { valid: false, error: "File not found" };
   }
   ```

5. **Clear retry loop** - The `do/while` pattern makes retry logic explicit and controlled by the caller.

**Validation Definition:**

Validation is defined on Ask components, not in requirements:

```tsx
// Built-in validation props
<Ask.File name="config" mustExist />
<Ask.Path name="output" mustBeDirectory />
<Ask.Text name="email" pattern="^[^@]+@[^@]+$" />

// Custom validators registered at iterator creation
const iterator = createInputIterator({
  validators: {
    "server-reachable": async (value) => {
      const ok = await checkServer(value);
      return ok ? { valid: true } : { valid: false, error: "Server unreachable" };
    },
  },
});

// Used in prompt
<Ask.Text name="server" validator="server-reachable" />
```

---

### Component Model: Class-Based with Inheritance

**Decision:** Components are classes that extend a `Component<Props>` base class, rather than objects created by a factory function.

```typescript
// Class-based (chosen)
export class AcmeHeader extends Component<{ title: string }> {
  render({ title }, context) {
    return `=== ${title} ===`;
  }
}

// Factory function (rejected)
const AcmeHeader = defineComponent({
  name: 'AcmeHeader',
  render: ({ title }) => `=== ${title} ===`,
});
```

**Alternatives Considered:**

| Option | Description | Pros | Cons |
|--------|-------------|------|------|
| **Factory function** | `defineComponent({ name, render })` | Simple, functional style | Requires explicit name, no inheritance |
| **Class-based** | `class Foo extends Component` | Auto-discovery via `instanceof`, familiar OOP | Slightly more verbose |
| **Decorator-based** | `@component class Foo` | Clean syntax | Extra syntax, still needs decorator |

**Why Class-Based:**
- **Auto-discovery:** `instanceof Component` check enables automatic registration when modules are loaded
- **No explicit name:** Component name comes from the export name, not a separate property
- **Familiar pattern:** Similar to React class components, widely understood
- **Inheritance works:** Can create base components that others extend
- **Python parallel:** Similar to Python's `__init_subclass__` pattern for auto-registration

---

### Conditional Syntax: Excel Formulas

**Decision:** Conditional rendering uses Excel formula syntax, evaluated by [hot-formula-parser](https://www.npmjs.com/package/hot-formula-parser). This makes conditions accessible to non-technical users familiar with spreadsheets.

```tsx
// Excel formula syntax (chosen)
<If when='=AND(count>5, userType="admin")'>
<If when='=NOT(ISBLANK(notes))'>

// JavaScript expression (available for power users)
<If when={items.filter(i => i.priority > 3).length >= 2}>
```

**Alternatives Considered:**

| Option | Description | Pros | Cons |
|--------|-------------|------|------|
| **Natural language** | `when="userType is admin"` | Very readable | Ambiguous, hard to parse reliably |
| **Attribute-based** | `<If input="count" greaterThan={5}>` | Pure markup | Can't express complex conditions |
| **JavaScript expressions** | `when="count > 5 && type === 'admin'"` | Full power | Intimidating to non-technical users |
| **Excel formulas** | `when='=AND(count>5, type="admin")'` | Familiar to business users | Need formula parser library |

**Why Excel Formulas:**
- **Target audience:** Non-technical users are often very familiar with Excel
- **Readable:** `AND(a, b)` is clearer than `a && b` for non-programmers
- **Powerful:** Supports complex logic without learning JavaScript
- **Existing library:** hot-formula-parser handles parsing and evaluation
- **Fallback available:** JavaScript expressions still work for power users

**Supported Functions:**
- Logical: `AND`, `OR`, `NOT`
- Comparison: `=`, `<>`, `>`, `<`, `>=`, `<=`
- Text: `LEN`, `ISBLANK`, `CONTAINS`, `STARTSWITH`, `ENDSWITH`
- Date: `TODAY`, `NOW`

---

### User Input Syntax: Child Elements + JS Attributes

**Decision:** User input components (`Ask.*`) support two syntaxes: child elements for simple cases (non-technical users) and JS attributes for dynamic/complex cases (power users).

```tsx
// Child elements - simple, no JavaScript knowledge needed
<Ask.Select name="framework" label="Which framework?">
  <Option value="react">React</Option>
  <Option value="vue">Vue</Option>
</Ask.Select>

// JS attributes - for dynamic data
<Ask.Select
  name="framework"
  options={frameworks.map(f => ({ value: f.id, label: f.name }))}
/>
```

**Alternatives Considered:**

| Option | Description | Pros | Cons |
|--------|-------------|------|------|
| **JS only** | `options={[...]}` | Consistent, powerful | JavaScript syntax intimidates non-technical users |
| **Child elements only** | `<Option>` children | Pure markup | Verbose for dynamic data |
| **String parsing** | `options="React, Vue, Angular"` | Simple | Can't handle complex values or labels |
| **Hybrid (chosen)** | Child elements + JS attributes | Best of both worlds | Two ways to do the same thing |

**Why Hybrid:**
- **Progressive complexity:** Simple cases look simple, complex cases are still possible
- **Non-technical friendly:** Child elements are pure markup, no JavaScript
- **Power user friendly:** JS attributes available when needed
- **Precedent:** Similar to how HTML works (inline styles vs CSS, onclick vs addEventListener)

**Components with child element support:**
- `Ask.Select` → `<Option value="x">Label</Option>`
- `Ask.MultiSelect` → `<Option value="x">Label</Option>`
- `Ask.Rating` → `<Label value="1">Low</Label>`

---

### Module Loading: URL-Based with Auto-Discovery

**Decision:** Libraries can be loaded from URLs, npm packages, or local paths using a unified `loadModule()` API. Components and prompts are auto-discovered by scanning module exports.

```typescript
// All source types use the same API
await loadModule('https://prompts.acme.com/v1.0.0/index.js');  // URL
await loadModule('@acme/prompts');                              // npm
await loadModule('./my-prompts/index.js');                      // local
```

**Alternatives Considered:**

| Option | Description | Pros | Cons |
|--------|-------------|------|------|
| **npm only** | Require npm packages | Familiar, versioned | Non-technical users can't use npm |
| **Config file** | List libraries in YAML/JSON | Declarative | Another file to manage |
| **URL-based** | Load from any URL | Works without npm | Less discoverability |
| **Unified loadModule()** | URLs, npm, and paths | Maximum flexibility | More complex resolution logic |

**Why Unified loadModule():**
- **Non-technical users:** Can use URL-based libraries without learning npm
- **Teams:** Can host internal libraries on any web server
- **npm users:** Still works with npm packages
- **Flexibility:** Same API regardless of source

**Auto-discovery rationale:**
- **Zero boilerplate:** Just export Component subclasses and Prompt elements
- **Component name = export name:** No separate `name` property to maintain
- **Library metadata optional:** Default export with `{ name, version, dependencies }` is optional
- **Python-like:** Similar to how Python's import system discovers classes

---

### Dependency Declaration: `<Uses>` Component

**Decision:** Prompt files can optionally declare their module dependencies using `<Uses src="...">` elements at the file level (outside `<Prompt>`). Dependencies are optional - when a component is not found, the runtime provides helpful error messages suggesting which package to install.

```xml
<Uses src="@acme/components" />
<Uses src="https://example.com/utils.js" />

<Prompt name="support" description="Customer support response">
  <AcmeHeader />
  <Role>Support agent</Role>
  <Task>Help the customer</Task>
</Prompt>
```

**Key behaviors:**

| Scenario | Result |
|----------|--------|
| `<Prompt>Say hi</Prompt>` (no deps) | Works - only uses built-ins |
| `<AcmeHeader>` with package installed | Works - component found in registry |
| `<AcmeHeader>` without package installed | Error: "AcmeHeader not found. Available in @acme/components" |
| `<Uses>` present, package not installed | Auto-install or prompt user to install |
| `<Uses>` present, package installed | Works |

**Source formats supported:**

| Format | Example |
|--------|---------|
| npm package | `<Uses src="@acme/components" />` |
| npm with version | `<Uses src="@acme/components@1.0.0" />` |
| URL | `<Uses src="https://cdn.example.com/components.js" />` |
| GitHub | `<Uses src="github:acme/components#v1.0.0" />` |
| Local (CLI only) | `<Uses src="./my-components/" />` |

---

#### Sub-Decision: No YAML Frontmatter

**Decision:** Use `<Prompt name="..." description="...">` attributes for metadata instead of YAML frontmatter.

**Rejected approach:**
```yaml
---
name: support-ticket
description: Customer support response
uses:
  - @acme/components
---
<Prompt>
  <AcmeHeader />
  ...
</Prompt>
```

**Chosen approach:**
```xml
<Uses src="@acme/components" />

<Prompt name="support-ticket" description="Customer support response">
  <AcmeHeader />
  ...
</Prompt>
```

**Why no frontmatter:**
- **Consistent syntax:** Entire file uses XML/JSX syntax, not a mix of YAML and XML
- **Simpler parsing:** One parser, not two
- **Familiar to target users:** Non-technical users already see `<Prompt>` as the container

---

#### Sub-Decision: `<Uses>` Placement (Outside Prompt)

**Decision:** `<Uses>` elements go at file level, outside `<Prompt>` elements.

**Alternatives Considered:**

| Option | Example | Pros | Cons |
|--------|---------|------|------|
| **Inside Prompt** | `<Prompt><Uses src="..."/><Role>...</Role></Prompt>` | Self-contained per prompt | Redundant when multiple prompts share deps |
| **Outside Prompt** | `<Uses src="..."/><Prompt>...</Prompt>` | Applies to all prompts in file | Less explicit per-prompt |
| **Attribute on Prompt** | `<Prompt uses="@acme/components">` | Compact | Limited to single format, less extensible |

**Why outside:**
- **File-level scope:** Dependencies apply to all prompts in the file
- **No redundancy:** Declare once, use in multiple prompts
- **Clear separation:** Metadata/dependencies separate from content
- **Extensible:** `<Uses>` can gain attributes (e.g., `optional`, `as`) without changing Prompt

---

#### Sub-Decision: Single `src` Attribute for All Formats

**Decision:** Use a single `src` attribute that accepts any source format, rather than separate attributes per format.

**Rejected approach:**
```xml
<Uses package="@acme/components" />
<Uses url="https://example.com/lib.js" />
<Uses git="github:acme/prompts#v1.0.0" />
```

**Chosen approach:**
```xml
<Uses src="@acme/components" />
<Uses src="https://example.com/lib.js" />
<Uses src="github:acme/prompts#v1.0.0" />
```

**Why single attribute:**
- **Simpler:** One attribute to learn
- **Flexible:** Format detected from value (URLs start with http/https, npm packages have @ or /, etc.)
- **Consistent:** Same pattern as HTML `<script src="...">` and `<img src="...">`

---

#### Sub-Decision: Optional Dependencies with Helpful Errors

**Decision:** `<Uses>` is optional. When a component is not found and no `<Uses>` declares it, the runtime provides a helpful error suggesting which package to install.

**The core problem:** Someone has to specify where components come from. The question is who and where.

**Alternatives Considered:**

| Option | Who specifies | Where | Trade-off |
|--------|--------------|-------|-----------|
| **Always required in prompt** | Prompt author | `<Uses>` in file | Self-contained but verbose |
| **App-level config only** | App developer | Config file or code | Clean prompts but not portable |
| **CLI flags only** | CLI user | Command line | Flexible but tedious |
| **Convention-based** | File system | Directory structure | Magic but limited |
| **Optional + helpful errors** | Prompt author (optional) | `<Uses>` or nothing | Best of both |

**Why optional with helpful errors:**
- **Simplest case stays simple:** `<Prompt>Say hi</Prompt>` works with zero setup
- **Installed packages just work:** No need to redeclare what's already available
- **Portability when needed:** Add `<Uses>` to make a file self-contained for sharing
- **Good DX:** Clear error messages guide users to the fix

**Example helpful error:**
```
Error: Component "AcmeHeader" not found.

This component is available in:
  - @acme/components (npm)
  - https://acme.com/prompts/components.js

To fix, either:
  1. Add <Uses src="@acme/components" /> to your prompt file
  2. Run: pt install @acme/components
```

This requires a **component registry** that maps component names to packages - either a central public registry or embedded in package metadata when published.

---

### Unified Module Loading: `Pupt` Class

**Decision:** Provide a single `Pupt` class that handles module loading for both CLI (Node.js) and browser environments, with automatic deduplication and browser import map generation.

```typescript
import { Pupt } from 'pupt-lib';

const pupt = new Pupt({
  modules: [
    '@acme/prompts',                    // npm
    'github:corp/prompts#v1.0.0',       // git
    'https://example.com/prompts.js',   // URL
  ],
});

await pupt.init();  // Loads all modules, deduplicates, generates import map (browser)
const prompts = pupt.getPrompts();
```

**The core problems solved:**

1. **Multiple source types:** npm, URLs, git, local files all need to work
2. **Deduplication:** Same module shouldn't be loaded twice
3. **Dependency ordering:** Dependencies must load before dependents
4. **Browser compatibility:** How do dynamic imports resolve `'pupt-lib'` in browsers?
5. **Cross-environment API:** Same code should work in Node.js and browsers

**Alternatives Considered:**

| Option | Description | Pros | Cons |
|--------|-------------|------|------|
| **Separate functions** | `loadModule()`, `getPrompts()` as standalone | Simple API surface | No shared state, repeated dedup logic |
| **Global registry** | Single global that tracks loaded modules | Easy to use | Implicit state, testing difficulties |
| **Factory function** | `createPupt(config)` returns instance | Functional style | Same as class, just different syntax |
| **Class instance** | `new Pupt(config)` | Explicit state, testable, extensible | Slightly more verbose |

**Why class-based `Pupt`:**
- **Explicit state:** Each instance tracks its own loaded modules (no globals)
- **Testable:** Easy to create isolated instances for testing
- **Extensible:** Can add methods like `loadModule()`, `hasComponent()`, etc.
- **Lifecycle:** Clear `init()` step for async setup (browser import maps)

---

#### Sub-Decision: Browser Module Loading via Import Maps

**Decision:** In browsers, `Pupt.init()` generates and injects an import map before loading any modules. This ensures all modules share a single copy of `pupt-lib` and other dependencies.

**The core problem:**

When a library does:
```typescript
import { Component } from 'pupt-lib';
```

Where does `pupt-lib` come from in a browser? Unlike Node.js, browsers don't have `node_modules`.

**Alternatives Considered:**

| Option | Description | Pros | Cons |
|--------|-------------|------|------|
| **Bundle everything** | Each library bundles pupt-lib | Self-contained | Duplication, `instanceof` breaks |
| **Global variable** | `window.puptLib = ...` | Simple | Globals are bad practice |
| **Factory pattern** | Libraries export factory receiving pupt-lib | Explicit DI | Different authoring pattern |
| **Shared CDN URL** | All import from same URL | Browser caches | Libraries must coordinate |
| **Import maps** | Browser maps `'pupt-lib'` to URL | Standard, no library changes | Requires setup |
| **Build-time only** | No browser runtime loading | No complexity | Can't load dynamically |

**Why import maps:**
- **Standard:** Native browser feature, no polyfill needed (modern browsers)
- **No library changes:** Libraries use normal `import { Component } from 'pupt-lib'`
- **Deduplication:** All references to same specifier resolve to same URL
- **Version control:** Import map specifies exact versions
- **Automatic:** `Pupt.init()` generates the map, user doesn't manage it

**How it works:**

```typescript
// Pupt.init() in browser:
async function setupBrowserModules(sources: string[]): Promise<void> {
  // 1. Resolve full dependency tree for all sources
  const allDeps = await resolveDependencyTree(sources);

  // 2. Generate import map
  const importMap = {
    imports: {
      'pupt-lib': 'https://esm.sh/pupt-lib@1.0.0',
      '@acme/components': 'https://esm.sh/@acme/components@1.0.0',
      // ... all dependencies
    },
  };

  // 3. Inject before any dynamic imports
  const script = document.createElement('script');
  script.type = 'importmap';
  script.textContent = JSON.stringify(importMap);
  document.head.appendChild(script);
}
```

---

#### Sub-Decision: Module Deduplication Strategy

**Decision:** The loader tracks loaded modules by source and prevents duplicate loading. Dependencies are loaded recursively with the same deduplication.

**The problem:** When loading multiple modules that share dependencies:
```
@acme/prompts → depends on → @common/utils
@corp/prompts → depends on → @common/utils
```

Without deduplication, `@common/utils` loads twice.

**Implementation:**

```typescript
class ModuleLoader {
  private loaded = new Map<string, LoadedModule>();     // Completed
  private loading = new Map<string, Promise<LoadedModule>>(); // In progress

  async load(source: string): Promise<LoadedModule> {
    // Already loaded?
    if (this.loaded.has(source)) {
      return this.loaded.get(source)!;
    }

    // Currently loading? (handles concurrent requests for same module)
    if (this.loading.has(source)) {
      return this.loading.get(source)!;
    }

    // Start loading
    const promise = this.doLoad(source);
    this.loading.set(source, promise);

    const module = await promise;
    this.loaded.set(source, module);
    this.loading.delete(source);

    return module;
  }

  private async doLoad(source: string): Promise<LoadedModule> {
    // 1. Fetch manifest (including dependencies)
    const manifest = await this.fetchManifest(source);

    // 2. Load dependencies first (recursive, deduplicated)
    for (const dep of manifest.dependencies ?? []) {
      await this.load(dep);
    }

    // 3. Load this module
    return this.loadAndRegister(manifest);
  }
}
```

**Why this approach:**
- **Simple:** Map-based tracking is straightforward
- **Handles concurrency:** `loading` map prevents duplicate requests in flight
- **Recursive:** Dependencies use the same logic, automatically deduplicated

---

#### Sub-Decision: Environment Capability Declarations

**Decision:** Modules can declare required capabilities (filesystem, network) in their package metadata. The runtime warns when loading modules with incompatible capabilities.

**The problem:** Some components require capabilities not available in all environments:

```typescript
// Works in Node.js, fails in browser
class FileContents extends Component {
  async render() {
    return await fs.readFile(this.props.path, 'utf-8');
  }
}
```

**Solution:**

```json
// package.json
{
  "name": "@acme/file-utils",
  "pupt": {
    "capabilities": ["filesystem"]
  }
}
```

When loading in browser:
```
Warning: @acme/file-utils requires "filesystem" capability
which is not available in browsers.
Components from this module may not work correctly.
```

**Alternatives Considered:**

| Option | Description | Pros | Cons |
|--------|-------------|------|------|
| **Fail silently** | Components throw at render time | Simple | Bad DX, confusing errors |
| **Fail on load** | Refuse to load incompatible modules | Clear boundary | Might be too strict |
| **Warn on load** | Load but warn about incompatibility | Flexible, informative | Components may still fail |
| **Separate packages** | `@acme/prompts` vs `@acme/prompts-node` | Clear split | More packages to manage |

**Why warn on load:**
- **Informative:** User knows about potential issues upfront
- **Flexible:** Some components in the module might still work
- **Not blocking:** Doesn't prevent loading in mixed-use scenarios

---

## Scaffolding Tools

The following tools will be used for project scaffolding, based on the servherd reference project:

### Build & Development

| Tool | Version | Purpose |
|------|---------|---------|
| TypeScript | ^5.7.x | Type-safe JavaScript |
| Vite | ^6.x | Build tool and dev server |
| tsx | ^4.x | TypeScript execution for development |

### Testing

| Tool | Version | Purpose |
|------|---------|---------|
| Vitest | ^2.x | Test framework |
| @vitest/coverage-v8 | ^2.x | Code coverage provider |

### Linting & Code Quality

| Tool | Version | Purpose |
|------|---------|---------|
| ESLint | ^9.x | Code linting (flat config) |
| typescript-eslint | ^8.x | TypeScript ESLint support |
| @stylistic/eslint-plugin | ^2.x | Code style enforcement |
| Knip | ^5.x | Unused dependency detection |

### Git Hooks & Commits

| Tool | Version | Purpose |
|------|---------|---------|
| Husky | ^9.x | Git hooks manager |
| Commitlint | ^20.x | Commit message linting |
| @commitlint/config-conventional | ^20.x | Conventional commits preset |
| Commitizen | ^4.x | Interactive commit CLI |
| cz-conventional-changelog | ^3.x | Changelog adapter |

### Release & CI/CD

| Tool | Version | Purpose |
|------|---------|---------|
| semantic-release | ^25.x | Automated versioning and releases |
| @semantic-release/npm | ^13.x | NPM publishing |
| @semantic-release/github | ^11.x | GitHub release creation |
| @semantic-release/git | ^10.x | Git tagging and changelog commit |
| @semantic-release/changelog | ^6.x | CHANGELOG.md generation |
| GitHub Actions | - | CI/CD workflows |

### JSX Transformation

| Tool | Version | Purpose |
|------|---------|---------|
| @babel/core | ^7.x | Babel core for JSX transformation |
| @babel/preset-typescript | ^7.x | TypeScript support |
| @babel/plugin-transform-react-jsx | ^7.x | JSX transformation |

---

## Architecture

### High-Level Architecture

```
┌─────────────────────────────────────────────────────────────────────┐
│                         Higher-Level Programs                        │
│                  (CLI, Web UI, Mobile App, AI Agent)                 │
└─────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────┐
│                            pupt-lib API                              │
│  ┌─────────────────┐  ┌──────────────────┐  ┌────────────────────┐  │
│  │  PromptRenderer │  │  InputCollector  │  │  LibraryLoader     │  │
│  │                 │  │                  │  │                    │  │
│  │  - render()     │  │  - getInputs()   │  │  - loadLibrary()   │  │
│  │  - validate()   │  │  - setValues()   │  │  - resolveImport() │  │
│  └─────────────────┘  └──────────────────┘  └────────────────────┘  │
└─────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────┐
│                         Core Components                              │
│  ┌─────────────────┐  ┌──────────────────┐  ┌────────────────────┐  │
│  │  JSX Runtime    │  │  Babel Transform │  │  Component         │  │
│  │                 │  │                  │  │  Registry          │  │
│  │  - jsx()        │  │  - transform()   │  │                    │  │
│  │  - jsxs()       │  │  - parse()       │  │  - register()      │  │
│  │  - Fragment     │  │                  │  │  - get()           │  │
│  └─────────────────┘  └──────────────────┘  └────────────────────┘  │
└─────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────┐
│                      Default Component Library                       │
│  ┌─────────────────────────────────────────────────────────────────┐│
│  │ CORE: <Role> <Task> <Context> <Format> <Constraint>             ││
│  │       <Audience> <Tone> <SuccessCriteria>                       ││
│  └─────────────────────────────────────────────────────────────────┘│
│  ┌─────────────────────────────────────────────────────────────────┐│
│  │ EXAMPLES: <Example> <Examples>                                  ││
│  │ REASONING: <Steps> <Step>                                       ││
│  │ DATA: <Data> <Code> <File>                                      ││
│  │ CONTROL: <Conditional> <Repeat> <Section>                       ││
│  └─────────────────────────────────────────────────────────────────┘│
│  ┌─────────────────────────────────────────────────────────────────┐│
│  │ USER INPUT: <Ask.Text> <Ask.Editor> <Ask.Select>                ││
│  │   <Ask.MultiSelect> <Ask.Confirm> <Ask.File> <Ask.Number>       ││
│  │   <Ask.Choice> <Ask.Rating> <Ask.Date> <Ask.Secret> <Ask.Path>  ││
│  └─────────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────────┘
```

### Data Flow

```
1. User writes JSX prompt template
           │
           ▼
2. Babel transforms JSX to function calls
           │
           ▼
3. JSX Runtime creates component tree
           │
           ▼
4. InputCollector extracts required inputs from tree
           │
           ▼
5. Higher-level program collects input values from user
           │
           ▼
6. InputCollector receives values, updates component tree
           │
           ▼
7. PromptRenderer traverses tree, produces text output
           │
           ▼
8. Text prompt ready for LLM
```

---

## JSX Component System

### Custom JSX Runtime

pupt-lib implements a custom JSX runtime that does NOT depend on React. The runtime is designed specifically for text generation.

**Key Design Choice:** The JSX runtime outputs **string-based element types** (Option B), not component references. Components are resolved from a scoped registry at render time. See [Design Decisions](#design-decisions) for rationale.

```typescript
// src/jsx-runtime/index.ts

export interface PuptElement {
  /** Component name as string - resolved from registry at render time */
  type: string;
  props: Record<string, unknown>;
  children: PuptNode[];
}

export type PuptNode =
  | PuptElement
  | string
  | number
  | boolean
  | null
  | undefined
  | PuptNode[];

/**
 * JSX factory function - always receives string type names.
 * Babel transforms <Role>...</Role> to jsx("Role", { ... })
 */
export function jsx(
  type: string,
  props: Record<string, unknown>,
  key?: string
): PuptElement;

export function jsxs(
  type: string,
  props: Record<string, unknown>,
  key?: string
): PuptElement;

export const Fragment: unique symbol;
```

### Component Interface

Components are classes that extend the `Component<Props>` base class. Components are auto-discovered when their module is loaded—any named export that extends `Component` is automatically registered.

```typescript
// src/types/component.ts

export interface RenderContext {
  /** Current indentation level */
  indent: number;
  /** Collected input values */
  inputs: Record<string, unknown>;
  /** Parent component chain for context */
  ancestors: PuptElement[];
  /** Environmental configuration */
  env: EnvironmentContext;
  /** Scope loader for resolving components */
  scopeLoader: ScopeLoader;
}

/**
 * Base class for all components.
 *
 * Components are auto-discovered when their module is loaded.
 * The component name is the export name from the module.
 *
 * @example
 * // This component is registered as "AcmeHeader" (the export name)
 * export class AcmeHeader extends Component<{ title: string }> {
 *   render({ title }: { title: string }, context: RenderContext): string {
 *     return `=== ${title} ===`;
 *   }
 * }
 */
export abstract class Component<Props = {}> {
  /**
   * Render the component to a string.
   * @param props - The component's props
   * @param context - Render context with inputs, environment, etc.
   */
  abstract render(props: Props, context: RenderContext): string;
}
```

**Example component library:**

```typescript
// @acme/prompts/src/index.ts
import { Component, Prompt, Role, Task } from 'pupt-lib';

// Components - auto-discovered via instanceof Component
export class AcmeHeader extends Component<{ title: string; level?: number }> {
  render({ title, level = 1 }: { title: string; level?: number }) {
    const prefix = '#'.repeat(level);
    return `${prefix} ${title}`;
  }
}

export class AcmeFooter extends Component<{ company?: string }> {
  render({ company = 'ACME Corp' }: { company?: string }) {
    return `---\n© ${new Date().getFullYear()} ${company}`;
  }
}

// Prompts - auto-discovered via <Prompt> element check
export const supportTicket = (
  <Prompt name="support-ticket" tags={['support', 'customer']}>
    <AcmeHeader title="Support Request" />
    <Role>You are a helpful support agent.</Role>
    <Task>Help the customer with their issue.</Task>
  </Prompt>
);

// Optional metadata - provides library name, version, and dependencies
export default {
  name: 'acme-prompts',
  version: '1.0.0',
  dependencies: ['@common/utils'],  // Other libraries to load first
};
```

### Environment Context

The `EnvironmentContext` provides configuration that components use to optimize their output. This enables context-dependent rendering (e.g., XML tags for Claude, markdown for GPT) without hardcoding behavior.

> **API Stability Note:** The EnvironmentContext will be accessed via a proxy-based pattern before v1.0.0 to allow internal changes without breaking prompts. See [Design Decisions > Environment Context API Stability](#environment-context-api-stability-future-work) for details.

```typescript
// src/types/context.ts

export interface LlmConfig {
  /** Target LLM for optimization */
  model: "claude" | "gpt" | "gemini" | "llama" | "generic";
  /** Model variant hint (e.g., "opus", "sonnet", "4o", "pro") */
  variant?: string;
  /** Model capabilities that affect output */
  capabilities?: {
    /** Supports extended thinking / chain-of-thought */
    extendedThinking?: boolean;
    /** Supports tool/function calling */
    toolUse?: boolean;
    /** Supports vision/image input */
    vision?: boolean;
  };
}

export interface CodeConfig {
  /** Primary programming language context */
  language?: string;
  /** Framework in use (e.g., "react", "express", "django") */
  framework?: string;
  /** Package manager preference */
  packageManager?: "npm" | "yarn" | "pnpm" | "pip" | "cargo" | "go";
  /** Project type hint */
  projectType?: "web" | "cli" | "library" | "api" | "mobile";
}

export interface OutputConfig {
  /** Preferred delimiter style for sections */
  delimiterStyle: "xml" | "markdown" | "plain";
  /** Whether to include component metadata as comments */
  includeMetadata?: boolean;
  /** Line width hint for wrapping (0 = no wrap) */
  lineWidth?: number;
}

export interface RuntimeConfig {
  /** Current hostname */
  hostname: string;
  /** Current username */
  username: string;
  /** Current working directory */
  cwd: string;
  /** Current date/time (ISO string) */
  datetime: string;
  /** Current date (YYYY-MM-DD) */
  date: string;
  /** Current time (HH:MM:SS) */
  time: string;
  /** Unix timestamp (seconds) */
  timestamp: number;
}

export interface EnvironmentContext {
  /** LLM targeting configuration */
  llm: LlmConfig;
  /** Code/programming context */
  code?: CodeConfig;
  /** Output formatting preferences */
  output: OutputConfig;
  /** Runtime values (hostname, username, datetime, etc.) */
  runtime: RuntimeConfig;
  /** Custom extension properties for third-party components */
  extensions: Record<string, unknown>;
}
```

#### Default Environment

```typescript
// src/types/context.ts

import os from "os";

/**
 * Generate runtime config with current values
 */
export function createRuntimeConfig(): RuntimeConfig {
  const now = new Date();
  return {
    hostname: os.hostname(),
    username: os.userInfo().username,
    cwd: process.cwd(),
    datetime: now.toISOString(),
    date: now.toISOString().split("T")[0],
    time: now.toTimeString().split(" ")[0],
    timestamp: Math.floor(now.getTime() / 1000),
  };
}

export const DEFAULT_ENVIRONMENT: EnvironmentContext = {
  llm: { model: "generic" },
  output: { delimiterStyle: "xml" },
  runtime: createRuntimeConfig(),
  extensions: {},
};

/**
 * Create environment optimized for a specific LLM
 */
export function createEnvironment(model: LlmConfig["model"], options?: Partial<EnvironmentContext>): EnvironmentContext {
  const defaults: Record<LlmConfig["model"], Partial<EnvironmentContext>> = {
    claude: { output: { delimiterStyle: "xml" } },
    gpt: { output: { delimiterStyle: "markdown" } },
    gemini: { output: { delimiterStyle: "markdown" } },
    llama: { output: { delimiterStyle: "plain" } },
    generic: { output: { delimiterStyle: "xml" } },
  };

  return {
    ...DEFAULT_ENVIRONMENT,
    runtime: createRuntimeConfig(),  // Fresh runtime values
    ...defaults[model],
    ...options,
    llm: { model, ...options?.llm },
  };
}
```

#### Component Usage of Environment

Components read `context.env` to adapt their output:

```typescript
// src/components/structural/Role.tsx

const Role = defineComponent({
  name: "Role",
  props: z.object({
    expertise: z.string().optional(),
    domain: z.string().optional(),
    children: z.any(),
  }),
  render: ({ children, expertise, domain }, context) => {
    const content = renderChildren(children, context);
    const { delimiterStyle } = context.env.output;

    // Adapt output format based on environment
    if (delimiterStyle === "xml") {
      return `<role>\n${content}\n</role>`;
    } else if (delimiterStyle === "markdown") {
      return `## Role\n\n${content}`;
    } else {
      return `Role: ${content}`;
    }
  },
});
```

#### LLM-Specific Optimization Guidelines

| LLM | Recommended delimiterStyle | Notes |
|-----|---------------------------|-------|
| claude | xml | Trained with XML tags, better section parsing |
| gpt | markdown | Strong markdown understanding, good with headers |
| gemini | markdown | Prefers structured markdown |
| llama | plain | Simpler formatting often works better |
| generic | xml | Safe default with clear structure |

---

## User Input Abstraction

### Design Philosophy

User input components are named `Ask.*` to avoid confusion with:
- "Prompt" - already used for LLM prompts
- "Input" - HTML form inputs
- "Query" - database operations

The "Ask" namespace clearly indicates these components request information from users.

### Input Component Types

```typescript
// src/components/ask/types.ts

export interface AskBaseProps {
  /** Unique identifier for this input */
  name: string;
  /** Human-readable label/question */
  label: string;
  /** Optional description/help text */
  description?: string;
  /** Default value if user provides nothing */
  default?: unknown;
  /** Whether this input is required */
  required?: boolean;
  /** Pre-supplied value (bypasses asking) */
  value?: unknown;
}

export interface AskTextProps extends AskBaseProps {
  /** Placeholder text */
  placeholder?: string;
  /** Validation pattern (regex string) */
  pattern?: string;
  /** Minimum length */
  minLength?: number;
  /** Maximum length */
  maxLength?: number;
}

export interface AskEditorProps extends AskBaseProps {
  /** Language hint for syntax highlighting */
  language?: string;
  /** Initial content for the editor */
  initialContent?: string;
}

export interface AskSelectProps extends AskBaseProps {
  /** Available options */
  options: Array<{
    value: string;
    label: string;
    description?: string;
  }>;
}

export interface AskMultiSelectProps extends AskSelectProps {
  /** Minimum selections required */
  min?: number;
  /** Maximum selections allowed */
  max?: number;
}

export interface AskConfirmProps extends AskBaseProps {
  /** Text for affirmative option */
  affirmLabel?: string;
  /** Text for negative option */
  denyLabel?: string;
}

export interface AskFileProps extends AskBaseProps {
  /** Allowed file extensions */
  extensions?: string[];
  /** Whether to allow multiple files */
  multiple?: boolean;
  /** Whether to include file contents or just paths */
  includeContents?: boolean;
}

export interface AskNumberProps extends AskBaseProps {
  /** Minimum value */
  min?: number;
  /** Maximum value */
  max?: number;
  /** Step increment */
  step?: number;
  /** Whether to allow decimals */
  integer?: boolean;
}
```

### Input Collection Interface

Higher-level programs use the `InputIterator` to discover and collect input values. The iterator uses **depth-first traversal** to ensure questions near each other in the prompt are asked together, providing a natural flow for users.

#### Why Depth-First?

Consider this prompt structure:

```tsx
<Prompt>
  <Section name="user-info">
    <Ask.Text name="name" />
    <Conditional when={inputs.name === "admin"}>
      <Ask.Text name="adminCode" />
    </Conditional>
    <Ask.Text name="email" />
  </Section>

  <Section name="project">
    <Ask.Text name="projectName" />
  </Section>
</Prompt>
```

**Depth-first order:** name → adminCode (if applicable) → email → projectName

This keeps related questions grouped. A breadth-first or multi-pass approach would ask name → email → projectName, then jump back to adminCode, which feels disjointed.

#### Input Requirement Interface

```typescript
// src/types/input.ts

export interface InputRequirement {
  /** Unique name/identifier */
  name: string;
  /** Type of input component */
  type: "text" | "editor" | "select" | "multiselect" | "confirm" | "file" | "number" | "choice" | "rating" | "date" | "secret" | "path";
  /** Display label */
  label: string;
  /** Description/help text */
  description?: string;
  /** Whether required */
  required: boolean;
  /** Default value */
  default?: unknown;
  /** Type-specific options (e.g., select options) */
  options?: unknown;
  /**
   * Validation constraints (declarative, for simple cases).
   * More complex validation uses the `validator` field.
   */
  validation?: {
    /** Regex pattern for string validation */
    pattern?: string;
    /** Minimum value (numbers) */
    min?: number;
    /** Maximum value (numbers) */
    max?: number;
    /** Minimum length (strings) */
    minLength?: number;
    /** Maximum length (strings) */
    maxLength?: number;
    /** For file/path: must exist on disk */
    mustExist?: boolean;
    /** For path: must be a directory */
    mustBeDirectory?: boolean;
    /** For text: validate as hostname (DNS lookup) */
    validateHostname?: boolean;
    /** For text: validate as URL (reachability check) */
    validateUrl?: boolean;
  };
  /**
   * Name of a custom validator registered via InputIteratorOptions.validators.
   * Used for complex validation that can't be expressed declaratively.
   */
  validator?: string;
  /** Path in component tree (for grouping/display) */
  path: string[];
  /** Depth in tree */
  depth: number;
  /** Parent section name if inside a <Section> */
  section?: string;
}
```

#### Input Iterator Interface

```typescript
// src/services/input-iterator.ts

export interface InputIteratorOptions {
  /**
   * Pre-supplied values. Questions with matching names will be skipped
   * and use these values instead of asking the user.
   */
  values?: Record<string, unknown> | Map<string, unknown>;

  /**
   * Non-interactive mode. When true:
   * - Questions with defaults use the default value automatically
   * - Questions without defaults throw an error
   * - No questions are surfaced to the caller
   */
  nonInteractive?: boolean;

  /**
   * What to do when a required question has no default in non-interactive mode.
   * - "error": Throw an error (default)
   * - "skip": Skip the question, leave value undefined (may cause validation errors)
   */
  onMissingDefault?: "error" | "skip";

  /**
   * Custom validators for Ask components that specify `validator="name"`.
   * Validators run inside pupt-lib, not in the caller.
   */
  validators?: Record<string, (value: unknown) => Promise<ValidationResult>>;
}

export interface ValidationResult {
  valid: boolean;
  error?: string;
}

export interface InputIterator {
  /**
   * Start iteration - returns the first requirement, or null if none.
   * Must be called before current(), submit(), or advance().
   */
  start(element: PuptElement): Promise<InputRequirement | null>;

  /**
   * Get the current requirement, or null if iteration is complete.
   * Returns the SAME object until advance() is called.
   * This allows UIs to know they're showing the same question (for retry).
   */
  current(): InputRequirement | null;

  /**
   * Submit an answer for the current requirement.
   * Runs async validation (may check files, network, APIs, etc.).
   * Does NOT advance to the next requirement.
   *
   * Call repeatedly until valid, then call advance().
   *
   * @returns ValidationResult - check .valid to see if answer was accepted
   */
  submit(value: unknown): Promise<ValidationResult>;

  /**
   * Advance to the next requirement after a valid submission.
   * Evaluates conditionals using all previously-stored valid answers.
   * Throws if current requirement hasn't been successfully submitted.
   *
   * @returns Next requirement, or null if iteration is complete
   */
  advance(): Promise<InputRequirement | null>;

  /**
   * Get all collected (validated) values.
   */
  getValues(): Map<string, unknown>;
}

/**
 * Create a new input iterator
 */
export function createInputIterator(options?: InputIteratorOptions): InputIterator;
```

**Usage pattern:**

```typescript
const iterator = createInputIterator(options);
let req = await iterator.start(element);

while (req) {
  let result: ValidationResult;

  do {
    const answer = await askUser(req, result?.error);
    result = await iterator.submit(answer);
  } while (!result.valid);

  req = await iterator.advance();
}

const values = iterator.getValues();
```

#### Non-Interactive Mode

For automation, CI/CD, or scripting where user interaction isn't possible:

```typescript
// Non-interactive: use defaults, error if required question has no default
const iterator = createInputIterator({ nonInteractive: true });

// Pre-supply some values, ask user for the rest
const iterator = createInputIterator({
  values: {
    projectName: "my-project",
    framework: "react",
  },
});

// Combine: pre-supply values, use defaults for rest, error if still missing
const iterator = createInputIterator({
  values: { projectName: "my-project" },
  nonInteractive: true,
});
```

#### Pre-Supplied Values

When values are pre-supplied, those questions are skipped entirely:

```typescript
// Prompt has: name, email, projectType
const iterator = createInputIterator({
  values: { name: "Alice", projectType: "web" },
});

let req = await iterator.start(element);
while (req) {
  console.log(req.name);  // Only prints "email" - others were pre-supplied
  await iterator.submit("alice@example.com");
  req = await iterator.advance();
}
```

#### Iterator Implementation Notes

```typescript
// src/services/input-iterator.ts

class InputIteratorImpl implements InputIterator {
  private values: Map<string, unknown> = new Map();
  private preSuppliedValues: Map<string, unknown>;
  private validators: Record<string, (value: unknown) => Promise<ValidationResult>>;
  private options: InputIteratorOptions;

  private element: PuptElement | null = null;
  private currentReq: InputRequirement | null = null;
  private currentSubmitted = false;
  private walkGenerator: AsyncGenerator<InputRequirement, void, void> | null = null;

  constructor(options: InputIteratorOptions = {}) {
    this.options = options;
    this.preSuppliedValues = new Map(
      Object.entries(options.values ?? {})
    );
    this.validators = options.validators ?? {};
  }

  async start(element: PuptElement): Promise<InputRequirement | null> {
    this.element = element;
    this.walkGenerator = this.walk(element, [], 0, undefined);
    return this.advanceInternal();
  }

  current(): InputRequirement | null {
    return this.currentReq;
  }

  async submit(value: unknown): Promise<ValidationResult> {
    if (!this.currentReq) {
      throw new Error("No current requirement. Call start() first.");
    }

    // Run validation
    const result = await this.validate(this.currentReq, value);

    if (result.valid) {
      this.values.set(this.currentReq.name, value);
      this.currentSubmitted = true;
    }

    return result;
  }

  async advance(): Promise<InputRequirement | null> {
    if (!this.currentSubmitted && this.currentReq) {
      throw new Error(
        `Cannot advance: current requirement "${this.currentReq.name}" has not been successfully submitted.`
      );
    }
    return this.advanceInternal();
  }

  private async advanceInternal(): Promise<InputRequirement | null> {
    if (!this.walkGenerator) {
      return null;
    }

    const result = await this.walkGenerator.next();
    if (result.done) {
      this.currentReq = null;
    } else {
      this.currentReq = result.value;
      this.currentSubmitted = false;
    }
    return this.currentReq;
  }

  private async *walk(
    node: PuptNode,
    path: string[],
    depth: number,
    section?: string
  ): AsyncGenerator<InputRequirement, void, void> {
    if (node === null || node === undefined) {
      return;
    }

    if (isAskComponent(node)) {
      const requirement = this.extractRequirement(node, path, depth, section);

      // Skip if pre-supplied
      if (this.preSuppliedValues.has(requirement.name)) {
        this.values.set(requirement.name, this.preSuppliedValues.get(requirement.name));
        return;
      }

      // Skip if non-interactive with default
      if (this.options.nonInteractive && requirement.default !== undefined) {
        this.values.set(requirement.name, requirement.default);
        return;
      }

      // Error if non-interactive without default
      if (this.options.nonInteractive) {
        if (this.options.onMissingDefault === "skip") {
          return;
        }
        throw new Error(
          `Non-interactive mode: no value or default for required input "${requirement.name}"`
        );
      }

      yield requirement;
    }
    else if (isConditional(node)) {
      // Evaluate condition with current validated values
      const conditionMet = this.evaluateCondition(node.props.when, this.values);

      if (conditionMet) {
        yield* this.walk(node.props.children, [...path, "Conditional"], depth + 1, section);
      }
    }
    else if (isSection(node)) {
      const sectionName = node.props.name;
      for (const child of getChildren(node)) {
        yield* this.walk(child, [...path, sectionName], depth + 1, sectionName);
      }
    }
    else if (hasChildren(node)) {
      const nodeName = getNodeName(node);
      for (const child of getChildren(node)) {
        yield* this.walk(child, [...path, nodeName], depth + 1, section);
      }
    }
  }

  private async validate(req: InputRequirement, value: unknown): Promise<ValidationResult> {
    // Check required
    if (req.required && (value === undefined || value === null || value === "")) {
      return { valid: false, error: `${req.label} is required` };
    }

    // Run declarative validations
    if (req.validation) {
      const v = req.validation;

      if (v.pattern && typeof value === "string") {
        if (!new RegExp(v.pattern).test(value)) {
          return { valid: false, error: `Does not match required pattern` };
        }
      }

      if (v.minLength && typeof value === "string" && value.length < v.minLength) {
        return { valid: false, error: `Must be at least ${v.minLength} characters` };
      }

      if (v.maxLength && typeof value === "string" && value.length > v.maxLength) {
        return { valid: false, error: `Must be at most ${v.maxLength} characters` };
      }

      if (v.min !== undefined && typeof value === "number" && value < v.min) {
        return { valid: false, error: `Must be at least ${v.min}` };
      }

      if (v.max !== undefined && typeof value === "number" && value > v.max) {
        return { valid: false, error: `Must be at most ${v.max}` };
      }

      // Async validations
      if (v.mustExist && typeof value === "string") {
        const exists = await this.checkFileExists(value);
        if (!exists) {
          return { valid: false, error: `File not found: ${value}` };
        }
      }

      if (v.mustBeDirectory && typeof value === "string") {
        const isDir = await this.checkIsDirectory(value);
        if (!isDir) {
          return { valid: false, error: `Not a directory: ${value}` };
        }
      }

      if (v.validateHostname && typeof value === "string") {
        const resolves = await this.checkHostnameResolves(value);
        if (!resolves) {
          return { valid: false, error: `Hostname does not resolve: ${value}` };
        }
      }

      if (v.validateUrl && typeof value === "string") {
        const reachable = await this.checkUrlReachable(value);
        if (!reachable) {
          return { valid: false, error: `URL not reachable: ${value}` };
        }
      }
    }

    // Run custom validator
    if (req.validator) {
      const customValidator = this.validators[req.validator];
      if (!customValidator) {
        throw new Error(`Unknown validator: ${req.validator}`);
      }
      return customValidator(value);
    }

    return { valid: true };
  }

  private evaluateCondition(
    condition: ((inputs: Record<string, unknown>) => boolean) | boolean,
    values: Map<string, unknown>
  ): boolean {
    if (typeof condition === "function") {
      // Wrap Map in Proxy so inputs.userType works (not just inputs.get("userType"))
      const proxy = this.createInputsProxy(values);
      return condition(proxy);
    }
    return Boolean(condition);
  }

  private createInputsProxy(values: Map<string, unknown>): Record<string, unknown> {
    return new Proxy({} as Record<string, unknown>, {
      get: (_, prop: string) => values.get(prop),
      has: (_, prop: string) => values.has(prop),
      ownKeys: () => Array.from(values.keys()),
      getOwnPropertyDescriptor: (_, prop: string) => {
        if (values.has(prop)) {
          return { configurable: true, enumerable: true, value: values.get(prop) };
        }
        return undefined;
      },
    });
  }

  getValues(): Map<string, unknown> {
    return new Map(this.values);
  }

  // Async helper methods (implementations would use fs, dns, fetch, etc.)
  private async checkFileExists(path: string): Promise<boolean> { /* ... */ }
  private async checkIsDirectory(path: string): Promise<boolean> { /* ... */ }
  private async checkHostnameResolves(hostname: string): Promise<boolean> { /* ... */ }
  private async checkUrlReachable(url: string): Promise<boolean> { /* ... */ }
}
```

#### Input Collector (Convenience Wrapper)

For simpler use cases, `InputCollector` wraps the iterator with automatic retry handling:

```typescript
// src/services/input-collector.ts

export interface InputCollectorOptions extends InputIteratorOptions {
  /**
   * Maximum retry attempts per question before throwing.
   * Default: 3
   */
  maxRetries?: number;
}

export interface InputCollector {
  /**
   * Collect all inputs by iterating through the element tree.
   * Handles validation and retry automatically.
   *
   * @param askFn - Called to get answer; receives error message on retry
   */
  collectAll(
    element: PuptElement,
    askFn: (requirement: InputRequirement, error?: string) => Promise<unknown>
  ): Promise<Map<string, unknown>>;

  /**
   * Get the underlying iterator for more control
   */
  createIterator(): InputIterator;
}

export function createInputCollector(options?: InputCollectorOptions): InputCollector {
  const maxRetries = options?.maxRetries ?? 3;

  return {
    async collectAll(element, askFn) {
      const iterator = createInputIterator(options);
      let req = await iterator.start(element);

      while (req) {
        let result: ValidationResult;
        let attempts = 0;

        do {
          const answer = await askFn(req, result?.error);
          result = await iterator.submit(answer);
          attempts++;

          if (!result.valid && attempts >= maxRetries) {
            throw new Error(
              `Max retries (${maxRetries}) exceeded for "${req.name}": ${result.error}`
            );
          }
        } while (!result.valid);

        req = await iterator.advance();
      }

      return iterator.getValues();
    },

    createIterator() {
      return createInputIterator(options);
    },
  };
}
```

### Example Usage by Higher-Level Program

```typescript
// Example: CLI using pupt-lib with validation

import { render, createInputCollector, InputRequirement } from "pupt-lib";
import inquirer from "inquirer";
import chalk from "chalk";

async function askUser(req: InputRequirement, error?: string): Promise<unknown> {
  // Show error from previous attempt
  if (error) {
    console.log(chalk.red(`Error: ${error}`));
  }

  if (req.type === "text") {
    const { answer } = await inquirer.prompt([{
      type: "input",
      name: "answer",
      message: req.label,
      default: req.default,
    }]);
    return answer;
  } else if (req.type === "select") {
    const { answer } = await inquirer.prompt([{
      type: "list",
      name: "answer",
      message: req.label,
      choices: req.options,
    }]);
    return answer;
  } else if (req.type === "confirm") {
    const { answer } = await inquirer.prompt([{
      type: "confirm",
      name: "answer",
      message: req.label,
      default: req.default,
    }]);
    return answer;
  } else if (req.type === "file") {
    const { answer } = await inquirer.prompt([{
      type: "input",
      name: "answer",
      message: req.label,
      default: req.default,
    }]);
    return answer;
  }
  // ... handle other types
  throw new Error(`Unsupported input type: ${req.type}`);
}

async function executePrompt(templatePath: string) {
  // 1. Load and parse the JSX template
  const element = await loadTemplate(templatePath);

  // 2. Collect all inputs with validation and retry
  const collector = createInputCollector({
    validators: {
      // Custom validator for server reachability
      "server-reachable": async (value) => {
        const reachable = await checkServerHealth(value as string);
        return reachable
          ? { valid: true }
          : { valid: false, error: "Server is not reachable" };
      },
    },
  });

  const values = await collector.collectAll(element, askUser);

  // 3. Render the prompt with collected (validated) values
  const result = render(element, { inputs: values });

  return result;
}
```

### Advanced: Manual Iterator Control

For UIs that need more control (e.g., displaying progress, custom retry logic):

```typescript
async function executePromptWithProgress(templatePath: string) {
  const element = await loadTemplate(templatePath);
  const iterator = createInputIterator();

  const history: Array<{ requirement: InputRequirement; answer: unknown }> = [];
  let req = await iterator.start(element);
  let questionNumber = 0;

  while (req) {
    questionNumber++;

    // Show current position
    console.log(`\nQuestion ${questionNumber}`);
    console.log(`Section: ${req.section ?? "main"}`);
    console.log(`Path: ${req.path.join(" > ")}`);

    let result: ValidationResult;
    let answer: unknown;

    do {
      // Show error from previous attempt
      if (result?.error) {
        console.log(chalk.red(`  ✗ ${result.error}`));
      }

      answer = await askUser(req);
      result = await iterator.submit(answer);
    } while (!result.valid);

    console.log(chalk.green(`  ✓ Accepted`));
    history.push({ requirement: req, answer });

    req = await iterator.advance();
  }

  // All values are already validated
  return render(element, { inputs: iterator.getValues() });
}
```

### React/Web UI Example

For React applications where the input component should persist across validation failures:

```tsx
function PromptForm({ element }: { element: PuptElement }) {
  const iteratorRef = useRef(createInputIterator());
  const [currentReq, setCurrentReq] = useState<InputRequirement | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(false);

  useEffect(() => {
    iteratorRef.current.start(element).then(setCurrentReq);
  }, [element]);

  const handleSubmit = async (value: unknown) => {
    setIsLoading(true);
    setError(null);

    const result = await iteratorRef.current.submit(value);

    if (result.valid) {
      const next = await iteratorRef.current.advance();
      setCurrentReq(next);  // null if done
    } else {
      setError(result.error ?? "Invalid input");
      // currentReq stays the same - same input component rendered
    }

    setIsLoading(false);
  };

  if (!currentReq) {
    return <PromptComplete values={iteratorRef.current.getValues()} />;
  }

  return (
    <div>
      {/* key={currentReq.name} ensures same component instance on retry */}
      <InputField
        key={currentReq.name}
        requirement={currentReq}
        error={error}
        disabled={isLoading}
        onSubmit={handleSubmit}
      />
    </div>
  );
}

---

## Third-Party Library Loading

### Library Resolution

Third-party prompt libraries can be loaded from configurable locations:

```typescript
// src/services/library-loader.ts

export interface LibraryLoaderConfig {
  /** Directories to search for libraries */
  searchPaths: string[];
  /** Whether to search node_modules */
  includeNodeModules?: boolean;
  /** Custom resolver function */
  customResolver?: (specifier: string) => string | null;
}

export interface LoadedLibrary {
  /** Library name/package name */
  name: string;
  /** Library version */
  version: string;
  /** Exported components */
  components: Map<string, ComponentDefinition>;
  /** Library metadata */
  metadata?: {
    description?: string;
    author?: string;
    homepage?: string;
  };
}

export interface LibraryLoader {
  /**
   * Configure search paths for libraries
   */
  configure(config: LibraryLoaderConfig): void;

  /**
   * Load a library by name or path
   */
  loadLibrary(specifier: string): Promise<LoadedLibrary>;

  /**
   * Resolve an import specifier to a file path
   */
  resolveImport(specifier: string, fromFile?: string): string | null;

  /**
   * Get all loaded libraries
   */
  getLoadedLibraries(): Map<string, LoadedLibrary>;

  /**
   * Register components from a library into the global registry
   */
  registerLibrary(library: LoadedLibrary): void;
}
```

---

## Component Registry

The `ComponentRegistry` manages component definitions, enabling lookup during rendering and registration of third-party components.

### Registry Interface

```typescript
// src/services/component-registry.ts

export interface ComponentRegistry {
  /**
   * Register a component definition.
   * @throws Error if component with same name already registered (unless override: true)
   */
  register(component: ComponentDefinition, options?: { override?: boolean }): void;

  /**
   * Register multiple components at once
   */
  registerAll(components: ComponentDefinition[], options?: { override?: boolean }): void;

  /**
   * Get a component by name
   * @returns undefined if not found
   */
  get(name: string): ComponentDefinition | undefined;

  /**
   * Check if a component is registered
   */
  has(name: string): boolean;

  /**
   * Get all registered component names
   */
  list(): string[];

  /**
   * Get all registered components
   */
  getAll(): Map<string, ComponentDefinition>;

  /**
   * Create a child registry that inherits from this one.
   * Child can override parent components without affecting parent.
   * Useful for testing or sandboxed execution.
   */
  createChild(): ComponentRegistry;

  /**
   * Unregister a component
   */
  unregister(name: string): boolean;

  /**
   * Clear all registered components
   * @param options.preserveBuiltins - Keep built-in pupt-lib components (default: true)
   */
  clear(options?: { preserveBuiltins?: boolean }): void;
}
```

### Default Registry

```typescript
// src/services/component-registry.ts

/**
 * Create a new registry with default pupt-lib components pre-registered
 */
export function createRegistry(): ComponentRegistry;

/**
 * Global default registry instance.
 * Used by render() when no custom registry is provided.
 */
export const defaultRegistry: ComponentRegistry;
```

### Registry Implementation

```typescript
// src/services/component-registry.ts

class ComponentRegistryImpl implements ComponentRegistry {
  private components: Map<string, ComponentDefinition>;
  private parent?: ComponentRegistry;
  private builtinNames: Set<string>;

  constructor(parent?: ComponentRegistry, builtins?: ComponentDefinition[]) {
    this.components = new Map();
    this.parent = parent;
    this.builtinNames = new Set();

    // Register builtins if provided
    if (builtins) {
      for (const component of builtins) {
        this.components.set(component.name, component);
        this.builtinNames.add(component.name);
      }
    }
  }

  register(component: ComponentDefinition, options?: { override?: boolean }): void {
    if (this.components.has(component.name) && !options?.override) {
      throw new Error(
        `Component "${component.name}" is already registered. ` +
        `Use { override: true } to replace it.`
      );
    }
    this.components.set(component.name, component);
  }

  registerAll(components: ComponentDefinition[], options?: { override?: boolean }): void {
    for (const component of components) {
      this.register(component, options);
    }
  }

  get(name: string): ComponentDefinition | undefined {
    // Check local registry first, then parent
    return this.components.get(name) ?? this.parent?.get(name);
  }

  has(name: string): boolean {
    return this.components.has(name) || (this.parent?.has(name) ?? false);
  }

  list(): string[] {
    const names = new Set(this.components.keys());
    if (this.parent) {
      for (const name of this.parent.list()) {
        names.add(name);
      }
    }
    return Array.from(names).sort();
  }

  getAll(): Map<string, ComponentDefinition> {
    const all = new Map<string, ComponentDefinition>();

    // Add parent components first (child overrides)
    if (this.parent) {
      for (const [name, component] of this.parent.getAll()) {
        all.set(name, component);
      }
    }

    // Add/override with local components
    for (const [name, component] of this.components) {
      all.set(name, component);
    }

    return all;
  }

  createChild(): ComponentRegistry {
    return new ComponentRegistryImpl(this);
  }

  unregister(name: string): boolean {
    return this.components.delete(name);
  }

  clear(options?: { preserveBuiltins?: boolean }): void {
    const preserveBuiltins = options?.preserveBuiltins ?? true;

    if (preserveBuiltins) {
      for (const name of this.components.keys()) {
        if (!this.builtinNames.has(name)) {
          this.components.delete(name);
        }
      }
    } else {
      this.components.clear();
    }
  }
}
```

### Usage Examples

#### Basic Registration

```typescript
import { defaultRegistry, defineComponent } from "pupt-lib";
import { z } from "zod";

// Define a custom component
const MyCustomSection = defineComponent({
  name: "MyCustomSection",
  props: z.object({
    title: z.string(),
    children: z.any(),
  }),
  render: ({ title, children }, context) => {
    const content = renderChildren(children, context);
    return `=== ${title} ===\n${content}\n${"=".repeat(title.length + 8)}`;
  },
});

// Register it
defaultRegistry.register(MyCustomSection);
```

#### Using with Third-Party Libraries

```typescript
import { defaultRegistry, LibraryLoader } from "pupt-lib";

const loader = new LibraryLoader();
const myPrompts = await loader.loadLibrary("@company/prompts");

// Register all components from the library
defaultRegistry.registerAll(
  Array.from(myPrompts.components.values())
);

// Or use the convenience method
loader.registerLibrary(myPrompts, defaultRegistry);
```

#### Scoped Registry for Testing

```typescript
import { defaultRegistry, render } from "pupt-lib";

// Create isolated registry for tests
const testRegistry = defaultRegistry.createChild();

// Override a component with a mock
testRegistry.register(mockRoleComponent, { override: true });

// Render with isolated registry - doesn't affect other tests
const output = render(element, { registry: testRegistry });
```

---

## Scope and Scope Loading

The `Scope` and `ScopeLoader` classes manage component resolution for package-based scoping. See [Design Decisions](#design-decisions) for rationale.

### Scope Class

A `Scope` is a component registry with parent chain for inheritance.

```typescript
// src/services/scope.ts

export class Scope {
  private components: Map<string, ComponentDefinition>;
  private parent?: Scope;
  readonly name: string;

  constructor(name: string, parent?: Scope);

  /** Register a component in this scope */
  register(component: ComponentDefinition): void;

  /** Register multiple components */
  registerAll(components: ComponentDefinition[]): void;

  /** Get a component by name (checks parent chain) */
  get(name: string): ComponentDefinition | undefined;

  /** Check if component exists (in this scope or parents) */
  has(name: string): boolean;

  /** List all available component names */
  list(): string[];

  /** List only this scope's components (not inherited) */
  listOwn(): string[];

  /** Debug: show scope chain */
  debugChain(): string[];
}

/** Built-in scope with all pupt-lib components */
export const builtinScope: Scope;

/** Create a new scope */
export function createScope(name: string, parent?: Scope): Scope;
```

### ScopeLoader Class

Loads packages, walks `package.json` dependencies, and builds scopes.

```typescript
// src/services/scope-loader.ts

export class ScopeLoader {
  /**
   * Load scope for an npm package.
   * Walks package.json to find pupt-lib dependencies.
   */
  async loadPackage(packageName: string, basedir?: string): Promise<Scope>;

  /**
   * Load scope for a file (finds owning package).
   */
  async loadForFile(filePath: string): Promise<Scope>;

  /**
   * Get scope for a specific package (must be already loaded).
   */
  getPackageScope(packageName: string): Scope | undefined;

  /**
   * Get combined scope of all loaded packages (for local prompts).
   */
  getCombinedScope(): Scope;

  /**
   * Get warnings generated during loading (circular deps, conflicts).
   */
  getWarnings(): string[];

  /**
   * Clear cache (useful for testing or hot reload).
   */
  clearCache(): void;
}
```

### How ScopeLoader Works

```
1. loadPackage("@acme/prompts")
   │
   ▼
2. Find package.json, read dependencies
   │
   ▼
3. For each dependency that is a pupt-lib library:
   │  └─> Recursively loadPackage(dependency)
   │
   ▼
4. Create Scope with builtinScope as parent
   │
   ▼
5. Merge dependency scopes into this scope
   │
   ▼
6. Load this package's components, register in scope
   │
   ▼
7. Cache and return scope
```

### Edge Case Handling

```typescript
// Circular dependency detection
const loading = new Set<string>();  // Track packages currently being loaded

async function loadPackage(name: string): Promise<Scope> {
  if (loading.has(name)) {
    warnings.push(`Circular dependency: ${name}`);
    return partialScope;  // Return what we have so far
  }

  loading.add(name);
  try {
    // ... load package ...
  } finally {
    loading.delete(name);
  }
}

// Diamond dependency handling
function mergeScope(target: Scope, source: Scope): void {
  for (const name of source.listOwn()) {
    if (target.has(name)) {
      warnings.push(`Component "${name}" already exists (first-loaded wins)`);
    } else {
      target.register(source.get(name)!);
    }
  }
}
```

### Detecting pupt-lib Libraries

A package is identified as a pupt-lib library if:

```typescript
async function isPuptLibrary(packageName: string): Promise<boolean> {
  const pkg = await readPackageJson(packageName);

  return (
    pkg.keywords?.includes('pupt-lib') ||
    pkg.peerDependencies?.['pupt-lib'] !== undefined
  );
}
```

---

## Third-Party Library Loading

### Library Package Structure

Libraries can be distributed via npm or hosted at any URL. The structure is simple: export Component subclasses and Prompt elements.

**Minimal structure (URL or npm):**

```
my-prompts/
├── package.json          # Standard npm package (no special fields required)
└── src/
    └── index.ts          # Export components, prompts, and optional metadata
```

**Full example (npm package):**

```
@acme/prompts/
├── package.json
├── src/
│   ├── index.ts          # Main entry - exports everything
│   ├── components/
│   │   ├── AcmeHeader.ts
│   │   └── AcmeFooter.ts
│   └── prompts/
│       ├── support-ticket.tsx
│       └── bug-report.tsx
└── dist/
    └── index.js          # Compiled output
```

**package.json (standard, no special fields required):**

```json
{
  "name": "@acme/prompts",
  "version": "1.0.0",
  "type": "module",
  "main": "./dist/index.js",
  "types": "./dist/index.d.ts"
}
```

**src/index.ts:**

```typescript
import { Component, Prompt, Role, Task } from 'pupt-lib';

// Components - auto-discovered
export class AcmeHeader extends Component<{ title: string }> {
  render({ title }) {
    return `=== ${title} ===`;
  }
}

export class AcmeFooter extends Component {
  render() {
    return '--- ACME Corp ---';
  }
}

// Prompts - auto-discovered
export const supportTicket = (
  <Prompt name="support-ticket" tags={['support']}>
    <AcmeHeader title="Support" />
    <Role>You are a support agent.</Role>
    <Task>Help the customer.</Task>
  </Prompt>
);

// Optional: metadata
export default {
  name: 'acme-prompts',
  version: '1.0.0',
  dependencies: [
    '@common/prompt-utils',  // npm dependency
    'https://shared.example.com/utils/v1.0.0/index.js',  // URL dependency
  ],
};
```

### Loading Libraries

```typescript
import { Pupt } from 'pupt-lib';

const pupt = new Pupt({
  modules: [
    '@acme/prompts',
    'https://prompts.corp.com/v1.0.0/index.js',
    './my-local-prompts/',
  ],
});

await pupt.init();
const prompts = pupt.getPrompts();
```

---

## Simple Prompt Format

For non-technical users, pupt-lib supports a simple `.prompt` file format that requires no build step.

### File Format

Simple prompts are XML-like files with no JavaScript:

```xml
<!-- greeting.prompt -->
<Prompt name="greeting" description="A friendly greeting">
  Say hello to the user
</Prompt>
```

With dependencies:

```xml
<!-- support.prompt -->
<Uses src="@acme/components" />

<Prompt name="support" description="Customer support response" tags="support, customer-service">
  <AcmeHeader title="Support Request" />

  <Ask.Text name="issue" label="What's the customer's issue?" />

  <Role>You are a helpful support agent</Role>
  <Task>Help the customer with: {inputs.issue}</Task>
</Prompt>
```

Multiple prompts in one file:

```xml
<!-- customer-prompts.prompt -->
<Uses src="@acme/components" />

<Prompt name="support-ticket" tags="support">
  <AcmeHeader />
  <Role>Support agent</Role>
  <Task>Help with the ticket</Task>
</Prompt>

<Prompt name="bug-report" tags="engineering">
  <AcmeHeader />
  <Role>Bug triage specialist</Role>
  <Task>Analyze the bug report</Task>
</Prompt>
```

### Runtime Parsing

`.prompt` files are parsed at runtime - no Babel/TypeScript build step required:

```typescript
// Internal: how .prompt files are processed
async function loadPromptFile(filePath: string): Promise<ParsedPromptFile> {
  const content = await fs.readFile(filePath, 'utf-8');

  // Parse XML-like syntax
  const ast = parsePromptSyntax(content);

  // Extract Uses declarations and load dependencies
  const uses = ast.filter(n => n.type === 'Uses');
  for (const use of uses) {
    await moduleLoader.load(use.props.src);
  }

  // Extract and return prompts
  const prompts = ast.filter(n => n.type === 'Prompt');
  return { uses, prompts, filePath };
}
```

### Variable Interpolation

Simple prompts support basic variable interpolation for inputs:

```xml
<Prompt name="greeting">
  <Ask.Text name="userName" label="What's your name?" />
  Hello, {inputs.userName}! Welcome to our service.
</Prompt>
```

For advanced logic (loops, conditionals, async data), use the `.tsx` format instead.

---

## Module Author Workflow

How to create and publish a component library.

### 1. Project Structure

```
my-components/
├── package.json
├── src/
│   ├── index.ts          # exports all components
│   ├── AcmeHeader.tsx
│   └── CustomerContext.tsx
└── dist/
    └── index.js          # built output
```

### 2. package.json

```json
{
  "name": "@acme/components",
  "version": "1.0.0",
  "type": "module",
  "main": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "peerDependencies": {
    "pupt-lib": "^1.0.0"
  },
  "pupt": {
    "capabilities": ["network"]
  }
}
```

The `pupt.capabilities` field declares what the components need:
- `network` - Makes HTTP requests
- `filesystem` - Reads/writes files (CLI only)

### 3. Component Implementation

```typescript
// src/index.ts
export { AcmeHeader } from './AcmeHeader';
export { CustomerContext } from './CustomerContext';
```

```typescript
// src/AcmeHeader.tsx
import { Component } from 'pupt-lib';

export class AcmeHeader extends Component<{ title?: string }> {
  render() {
    return <Section title={this.props.title ?? 'Acme Corp'} />;
  }
}
```

```typescript
// src/CustomerContext.tsx
import { Component } from 'pupt-lib';

export class CustomerContext extends Component<{ customerId: string }> {
  async render() {
    const customer = await fetch(`/api/customers/${this.props.customerId}`);
    return (
      <Context title="Customer">
        Name: {customer.name}
        Tier: {customer.tier}
      </Context>
    );
  }
}
```

### 4. Build and Publish

```bash
npm run build    # Compile TypeScript
npm publish      # Publish to npm
```

Or host `dist/index.js` on any CDN/web server for URL-based loading.

### Summary

| Step | Required? | Notes |
|------|-----------|-------|
| Extend `Component` class | Yes | Enables auto-discovery |
| Export from index | Yes | Named exports are discovered |
| peerDependency on pupt-lib | Yes | Ensures single pupt-lib instance |
| Declare capabilities | Optional | Helps runtime warn about incompatibilities |
| Default metadata export | Optional | Name/version can be inferred from package.json |

---

## Prompt Author Workflow

How to create and share prompts.

### Option A: Single File (No Build Step)

For simple prompts, just create a `.prompt` file:

```xml
<!-- my-prompt.prompt -->
<Prompt name="greeting" description="A friendly greeting">
  <Ask.Text name="name" label="What's your name?" />
  Hello, {inputs.name}! How can I help you today?
</Prompt>
```

**Share it:**
- Put in a git repo
- Upload to a gist
- Host on any web server
- Include in an npm package

### Option B: Package of Prompts

For a collection of related prompts:

```
my-prompts/
├── package.json
├── support-ticket.prompt
├── bug-report.prompt
└── feature-request.prompt
```

**package.json:**

```json
{
  "name": "@myteam/prompts",
  "version": "1.0.0",
  "pupt": {
    "prompts": ["./*.prompt"],
    "uses": ["@acme/components"]
  }
}
```

The `pupt.uses` field declares dependencies for all prompts in the package.

### Option C: Advanced Prompts (TypeScript)

For prompts that need loops, async data, or complex logic:

```typescript
// complex-report.prompt.tsx
import { Prompt, Role, Task, Context } from 'pupt-lib';

export default async function ComplexReport({ inputs }) {
  const data = await fetchReportData(inputs.reportId);

  return (
    <Prompt name="complex-report" tags={['reports']}>
      <Role>Data analyst</Role>
      <Task>Summarize this report</Task>
      <Context>
        {data.items.map(item => (
          <Item key={item.id} name={item.name} value={item.value} />
        ))}
      </Context>
    </Prompt>
  );
}
```

Requires build step (Babel/TypeScript), published like a module.

### Summary

| Approach | Build Step | Best For |
|----------|------------|----------|
| `.prompt` file | No | Simple prompts, non-technical users |
| Package of `.prompt` files | No | Team prompt libraries |
| `.tsx` file | Yes | Complex logic, async data, loops |

---

## Prompt Search

pupt-lib includes a fuzzy search service for discovering prompts across loaded libraries and local files.

### Search Design Decision

**Decision:** Use MiniSearch for full-text fuzzy search, integrated into the `Pupt` class with lazy indexing.

**Why MiniSearch:**

| Option | Description | Pros | Cons |
|--------|-------------|------|------|
| **MiniSearch** | Lightweight full-text search | Fast, browser-compatible, fuzzy matching, field boosting | External dependency |
| **Fuse.js** | Fuzzy search library | Popular, flexible | Slower for large datasets, no full-text indexing |
| **Lunr.js** | Full-text search | Mature, well-tested | Larger bundle, no fuzzy by default |
| **Custom implementation** | Hand-rolled search | No dependencies | More code to maintain, missing features |

**Why MiniSearch wins:**
- **Browser-compatible:** Works in both Node.js and browser (important for pupt-lib)
- **Fast:** Uses inverted index for O(1) lookups
- **Fuzzy matching:** Built-in typo tolerance (20% threshold)
- **Prefix matching:** "sup" matches "support"
- **Field boosting:** Name matches rank higher than content
- **Small bundle:** ~8KB minified

### Integration with Pupt Class

Search is integrated directly into the `Pupt` class with lazy indexing:

```typescript
export class Pupt {
  private searchEngine: SearchEngine | null = null;

  /** Lazily build search index on first search call */
  private getSearchEngine(): SearchEngine {
    if (!this.searchEngine) {
      this.searchEngine = createSearchEngine();
      const prompts = this.getPrompts();
      for (const prompt of prompts) {
        this.searchEngine.index({
          id: `${prompt.library}:${prompt.name}`,
          name: prompt.name,
          description: prompt.description,
          tags: prompt.tags,
          library: prompt.library,
          content: prompt.element.props.children?.toString(),
        });
      }
    }
    return this.searchEngine;
  }

  searchPrompts(query: string, options?: SearchOptions): SearchResult[] {
    return this.getSearchEngine().search(query, options);
  }

  getTags(): string[] {
    return this.getSearchEngine().getAllTags();
  }

  getPromptsByTag(tag: string): DiscoveredPrompt[] {
    const searchable = this.getSearchEngine().getByTag(tag);
    return searchable.map(s => this.getPrompt(s.name)!).filter(Boolean);
  }
}
```

**Why lazy indexing:**
- **Fast init:** `Pupt.init()` doesn't block on indexing
- **Pay for what you use:** Apps that don't search don't pay indexing cost
- **Automatic:** Index built transparently on first search call

### Search Field Weights

| Field | Boost | Rationale |
|-------|-------|-----------|
| `name` | 3x | Most specific - user often knows the name |
| `tags` | 2x | Categorical - good for discovery |
| `description` | 2x | Summary of purpose |
| `content` | 1x | Full text - broad but less specific |

### Search Behavior

| Feature | Value | Effect |
|---------|-------|--------|
| Fuzzy threshold | 0.2 | 20% typo tolerance ("suport" → "support") |
| Prefix matching | true | "sec" matches "security" |
| Combine with | AND | All terms must match |
| Default limit | 20 | Reasonable result set |

### Searchable Prompt Interface

```typescript
// src/services/search-engine.ts

export interface SearchablePrompt {
  /** Unique identifier (typically file path or library:name) */
  id: string;
  /** Prompt name from <Prompt name="..."> */
  name: string;
  /** Prompt description */
  description?: string;
  /** Tags for categorization */
  tags: string[];
  /** Semantic version */
  version?: string;
  /** Source library name (undefined for local prompts) */
  library?: string;
  /** File path if applicable */
  filePath?: string;
  /** Full prompt content for content search */
  content?: string;
}

export interface SearchResult {
  /** The matched prompt */
  prompt: SearchablePrompt;
  /** Relevance score (higher = better match) */
  score: number;
  /** Which fields matched */
  matches: Array<{
    field: "name" | "description" | "tags" | "content";
    /** Matched terms */
    terms: string[];
  }>;
}
```

### Search Options

```typescript
// src/services/search-engine.ts

export interface SearchOptions {
  /** Maximum results to return (default: 20) */
  limit?: number;
  /** Minimum score threshold (default: 0) */
  minScore?: number;
  /** Fields to search (default: all) */
  fields?: Array<"name" | "description" | "tags" | "content">;
  /** Filter by tags (AND logic - must have all specified tags) */
  filterTags?: string[];
  /** Filter by library name */
  filterLibrary?: string;
  /** Enable fuzzy matching (default: true) */
  fuzzy?: boolean;
  /** Fuzzy threshold 0-1, lower = more fuzzy (default: 0.2) */
  fuzzyThreshold?: number;
}
```

### Search Engine Interface

```typescript
// src/services/search-engine.ts

export interface SearchEngine {
  /**
   * Index a prompt for searching
   */
  index(prompt: SearchablePrompt): void;

  /**
   * Index multiple prompts at once
   */
  indexAll(prompts: SearchablePrompt[]): void;

  /**
   * Remove a prompt from the index
   */
  remove(id: string): boolean;

  /**
   * Clear all indexed prompts
   */
  clear(): void;

  /**
   * Search for prompts matching the query
   */
  search(query: string, options?: SearchOptions): SearchResult[];

  /**
   * Get all indexed prompts (unfiltered, unsorted)
   */
  getAll(): SearchablePrompt[];

  /**
   * Get prompts by tag
   */
  getByTag(tag: string): SearchablePrompt[];

  /**
   * Get prompts by library
   */
  getByLibrary(library: string): SearchablePrompt[];

  /**
   * Get all unique tags across indexed prompts
   */
  getAllTags(): string[];

  /**
   * Get all unique library names
   */
  getAllLibraries(): string[];

  /**
   * Get count of indexed prompts
   */
  count(): number;
}
```

### Search Engine Configuration

```typescript
// src/services/search-engine.ts

export interface SearchEngineConfig {
  /** Field boost weights for relevance scoring */
  fieldBoosts?: {
    name?: number;        // default: 3
    description?: number; // default: 2
    tags?: number;        // default: 2
    content?: number;     // default: 1
  };
  /** Default fuzzy matching threshold (default: 0.2) */
  fuzzyThreshold?: number;
  /** Enable prefix matching (default: true) */
  prefixMatch?: boolean;
}

/**
 * Create a new search engine instance
 */
export function createSearchEngine(config?: SearchEngineConfig): SearchEngine;
```

### Implementation Notes

Uses MiniSearch internally for fast full-text fuzzy search:

```typescript
// src/services/search-engine.ts

import MiniSearch from "minisearch";

class SearchEngineImpl implements SearchEngine {
  private miniSearch: MiniSearch<SearchablePrompt>;
  private prompts: Map<string, SearchablePrompt>;
  private config: Required<SearchEngineConfig>;

  constructor(config: SearchEngineConfig = {}) {
    this.prompts = new Map();
    this.config = {
      fieldBoosts: {
        name: config.fieldBoosts?.name ?? 3,
        description: config.fieldBoosts?.description ?? 2,
        tags: config.fieldBoosts?.tags ?? 2,
        content: config.fieldBoosts?.content ?? 1,
      },
      fuzzyThreshold: config.fuzzyThreshold ?? 0.2,
      prefixMatch: config.prefixMatch ?? true,
    };

    this.miniSearch = new MiniSearch({
      fields: ["name", "description", "tags", "content"],
      storeFields: ["name", "description", "tags", "version", "library", "filePath"],
      searchOptions: {
        boost: this.config.fieldBoosts,
        fuzzy: this.config.fuzzyThreshold,
        prefix: this.config.prefixMatch,
        combineWith: "AND",
      },
      // Handle tags array
      extractField: (doc, fieldName) => {
        if (fieldName === "tags") {
          return (doc as SearchablePrompt).tags.join(" ");
        }
        return (doc as Record<string, unknown>)[fieldName] as string;
      },
    });
  }

  index(prompt: SearchablePrompt): void {
    // Remove existing entry if re-indexing
    if (this.prompts.has(prompt.id)) {
      this.miniSearch.remove(this.prompts.get(prompt.id)!);
    }

    this.prompts.set(prompt.id, prompt);
    this.miniSearch.add(prompt);
  }

  indexAll(prompts: SearchablePrompt[]): void {
    for (const prompt of prompts) {
      this.index(prompt);
    }
  }

  search(query: string, options: SearchOptions = {}): SearchResult[] {
    const searchOptions = {
      fuzzy: options.fuzzy ?? true ? (options.fuzzyThreshold ?? this.config.fuzzyThreshold) : false,
      prefix: this.config.prefixMatch,
      fields: options.fields,
      filter: (result: { id: string }) => {
        const prompt = this.prompts.get(result.id);
        if (!prompt) return false;

        // Apply tag filter (AND logic)
        if (options.filterTags?.length) {
          if (!options.filterTags.every(tag => prompt.tags.includes(tag))) {
            return false;
          }
        }

        // Apply library filter
        if (options.filterLibrary && prompt.library !== options.filterLibrary) {
          return false;
        }

        return true;
      },
    };

    const results = this.miniSearch.search(query, searchOptions);

    return results
      .filter(r => r.score >= (options.minScore ?? 0))
      .slice(0, options.limit ?? 20)
      .map(r => ({
        prompt: this.prompts.get(r.id)!,
        score: r.score,
        matches: Object.entries(r.match).map(([field, terms]) => ({
          field: field as "name" | "description" | "tags" | "content",
          terms: terms as string[],
        })),
      }));
  }

  getAll(): SearchablePrompt[] {
    return Array.from(this.prompts.values());
  }

  getByTag(tag: string): SearchablePrompt[] {
    return this.getAll().filter(p => p.tags.includes(tag));
  }

  getByLibrary(library: string): SearchablePrompt[] {
    return this.getAll().filter(p => p.library === library);
  }

  getAllTags(): string[] {
    const tags = new Set<string>();
    for (const prompt of this.prompts.values()) {
      for (const tag of prompt.tags) {
        tags.add(tag);
      }
    }
    return Array.from(tags).sort();
  }

  getAllLibraries(): string[] {
    const libraries = new Set<string>();
    for (const prompt of this.prompts.values()) {
      if (prompt.library) {
        libraries.add(prompt.library);
      }
    }
    return Array.from(libraries).sort();
  }

  remove(id: string): boolean {
    const prompt = this.prompts.get(id);
    if (prompt) {
      this.miniSearch.remove(prompt);
      this.prompts.delete(id);
      return true;
    }
    return false;
  }

  clear(): void {
    this.miniSearch.removeAll();
    this.prompts.clear();
  }

  count(): number {
    return this.prompts.size;
  }
}
```

### Usage Examples

#### Basic Search

```typescript
import { createSearchEngine, LibraryLoader, Prompt } from "pupt-lib";

const search = createSearchEngine();
const loader = new LibraryLoader();

// Helper to check if element is a complete prompt
const isPrompt = (element: PuptElement) => element.type === Prompt;

// Index prompts from a library
const lib = await loader.loadLibrary("@company/prompts");
for (const [name, element] of lib.prompts) {
  if (isPrompt(element)) {
    search.index({
      id: `${lib.name}:${name}`,
      name: element.props.name as string,
      description: element.props.description as string | undefined,
      tags: (element.props.tags as string[]) ?? [],
      version: element.props.version as string | undefined,
      library: lib.name,
    });
  }
}

// Search for prompts
const results = search.search("security review", {
  filterTags: ["code"],
  limit: 10,
});

for (const { prompt, score } of results) {
  console.log(`${prompt.name} (score: ${score.toFixed(2)})`);
  console.log(`  Tags: ${prompt.tags.join(", ")}`);
  console.log(`  Library: ${prompt.library ?? "local"}`);
}
```

#### Interactive Search

```typescript
import { createSearchEngine } from "pupt-lib";
import readline from "readline";

const search = createSearchEngine();
// ... index prompts ...

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});

rl.on("line", (query) => {
  const results = search.search(query, { limit: 5 });

  if (results.length === 0) {
    console.log("No matches found");
  } else {
    for (const { prompt, score, matches } of results) {
      console.log(`\n${prompt.name} (${score.toFixed(1)})`);
      console.log(`  Matched: ${matches.map(m => m.field).join(", ")}`);
    }
  }
});
```

#### Browsing by Tag

```typescript
const search = createSearchEngine();
// ... index prompts ...

// List all tags
console.log("Available tags:", search.getAllTags().join(", "));

// Get all prompts with a specific tag
const securityPrompts = search.getByTag("security");
console.log(`Found ${securityPrompts.length} security prompts`);
```

---

## Runtime JSX Transformation

### Babel Configuration

pupt-lib uses Babel at runtime to transform JSX. This allows users to write `.tsx` files without a build step.

```typescript
// src/services/transformer.ts

export interface TransformOptions {
  /** Source file path (for error messages) */
  filename?: string;
  /** Source map generation */
  sourceMaps?: boolean;
  /** Additional Babel plugins */
  plugins?: string[];
}

export interface TransformResult {
  /** Transformed JavaScript code */
  code: string;
  /** Source map if requested */
  sourceMap?: object;
  /** Any warnings during transformation */
  warnings: string[];
}

export interface Transformer {
  /**
   * Transform JSX/TSX source to executable JavaScript
   */
  transform(source: string, options?: TransformOptions): TransformResult;

  /**
   * Transform and execute, returning the default export
   */
  transformAndExecute<T = PuptElement>(
    source: string,
    options?: TransformOptions
  ): Promise<T>;

  /**
   * Load and transform a file
   */
  loadFile(filePath: string): Promise<PuptElement>;
}
```

### Babel Preset Configuration

```typescript
// src/babel/preset.ts

export const puptBabelPreset = {
  presets: [
    ["@babel/preset-typescript", { isTSX: true, allExtensions: true }],
  ],
  plugins: [
    [
      "@babel/plugin-transform-react-jsx",
      {
        runtime: "automatic",
        importSource: "pupt-lib",
        throwIfNamespace: false,
      },
    ],
  ],
};
```

---

## Prompt Best Practices Integration

Based on research from Anthropic, OpenAI, Google, and academic sources, pupt-lib components encode prompt engineering best practices.

### Research-Backed Practices

#### 1. Clear Structure (All Vendors)

Components encourage clear sectioning:
- `<Section>` creates labeled, delimited sections
- `<Role>` establishes who/what the AI should be
- `<Task>` clearly states what to do
- `<Context>` provides background information

References:
- [Anthropic Claude Best Practices](https://docs.claude.com/en/docs/build-with-claude/prompt-engineering/claude-4-best-practices)
- [OpenAI Prompt Engineering](https://platform.openai.com/docs/guides/prompt-engineering)
- [Google Gemini Strategies](https://ai.google.dev/gemini-api/docs/prompting-strategies)

#### 2. XML-Style Tags (Claude Optimization)

Claude models were trained with XML tags. pupt-lib outputs XML-delimited sections by default:

```xml
<role>
You are an expert software architect...
</role>

<task>
Review the following code and provide feedback...
</task>
```

Reference: [Anthropic Prompt Engineering Tutorial](https://github.com/anthropics/prompt-eng-interactive-tutorial)

#### 3. Few-Shot Examples (All Vendors)

The `<Example>` component supports input/output pairs:

```tsx
<Example>
  <Example.Input>What is 2+2?</Example.Input>
  <Example.Output>4</Example.Output>
</Example>
```

Reference: [Chain-of-Thought Prompting Paper](https://arxiv.org/abs/2201.11903)

#### 4. Step-by-Step Reasoning (Chain-of-Thought)

The `<Steps>` component encourages explicit reasoning:

```tsx
<Steps>
  <Step>First, analyze the requirements</Step>
  <Step>Then, identify potential solutions</Step>
  <Step>Finally, recommend the best approach</Step>
</Steps>
```

Reference: [arXiv Survey on Prompt Engineering](https://arxiv.org/html/2402.07927v2)

#### 5. Success Criteria (Anthropic)

Explicitly stating what success looks like:

```tsx
<SuccessCriteria>
  <Criterion>Response is under 200 words</Criterion>
  <Criterion>All code examples compile</Criterion>
</SuccessCriteria>
```

#### 6. Positive Framing (KAIST Research)

Components encourage saying what TO do rather than what NOT to do. Research shows LLMs perform worse with negated instructions.

```tsx
// Good: Positive framing
<Constraint>Keep responses concise (2-3 sentences)</Constraint>

// Avoid: Negative framing
<Constraint>Don't write long responses</Constraint>
```

Reference: [Lakera Prompt Engineering Guide](https://www.lakera.ai/blog/prompt-engineering-guide)

#### 7. Output Format Specification (OpenAI, Google)

The `<Format>` component specifies expected output structure:

```tsx
<Format type="json" schema={outputSchema} />
<Format type="markdown" template="## Summary\n{content}" />
```

Reference: [Google Gemini Structured Output](https://docs.cloud.google.com/vertex-ai/generative-ai/docs/start/gemini-3-prompting-guide)

---

## Default Component Library

### Prompt Container Component

The `<Prompt>` component marks a top-level, complete prompt. This distinguishes executable prompts from reusable fragments.

```tsx
// Prompt: Marks a complete, executable prompt
<Prompt
  name="code-review"
  version="1.0.0"
  description="Review code for quality and security issues"
  tags={["code", "review", "security"]}
>
  <Role>You are a senior software engineer...</Role>
  <Task>Review the following code...</Task>
</Prompt>
```

#### Prompt Props Interface

```typescript
// src/components/structural/Prompt.tsx

export interface PromptProps {
  /** Unique identifier for this prompt */
  name: string;
  /** Semantic version */
  version?: string;
  /** Human-readable description */
  description?: string;
  /** Tags for categorization and search */
  tags?: string[];
  /** Prompt content */
  children: PuptNode;
}
```

#### Prompt vs Fragment

Files that export a `<Prompt>` wrapper are complete prompts. Files that export components without the wrapper are fragments (reusable pieces):

```tsx
// fragments/common-roles.tsx - These are FRAGMENTS
export const SecurityExpert = (
  <Role expertise="security">
    You are a security expert with 15 years of experience
    in application security, penetration testing, and secure code review.
  </Role>
);

export const CodeReviewer = (
  <Role expertise="code-review">
    You are a senior software engineer specializing in code quality.
  </Role>
);
```

```tsx
// prompts/security-review.tsx - This is a PROMPT
import { SecurityExpert } from "../fragments/common-roles";

export default (
  <Prompt name="security-review" version="1.0.0" tags={["security", "code"]}>
    {SecurityExpert}
    <Task>Analyze the following code for security vulnerabilities...</Task>
    <SuccessCriteria>
      <Criterion>Identify all OWASP Top 10 vulnerabilities</Criterion>
      <Criterion>Provide severity ratings for each finding</Criterion>
    </SuccessCriteria>
  </Prompt>
);
```

#### Checking if Element is a Prompt

To check if an element is a complete prompt (vs a fragment), simply check the element type:

```typescript
import { Prompt } from "pupt-lib";

function isCompletePrompt(element: PuptElement): boolean {
  return element.type === Prompt;
}

// Extract metadata directly from props
function getPromptMetadata(element: PuptElement) {
  if (!isCompletePrompt(element)) {
    return null;
  }
  return {
    name: element.props.name as string,
    version: element.props.version as string | undefined,
    description: element.props.description as string | undefined,
    tags: (element.props.tags as string[]) ?? [],
  };
}
```

### Core Structural Components

```tsx
// Section: Creates a labeled section with optional XML delimiters
<Section name="context" delimiter="xml">
  Content here
</Section>
// Output: <context>\nContent here\n</context>

// Role: Defines the persona/role for the AI (research: 28.4% usage, all frameworks)
<Role expertise="senior" domain="TypeScript">
  You are an expert TypeScript developer with 10 years of experience.
</Role>
// Output: <role>\nYou are an expert TypeScript developer...\n</role>

// Context: Provides background information (research: 56.2% usage)
<Context>
  The user is building a web application using React.
</Context>

// Task: Clearly states what the AI should do (research: 86.7% usage)
<Task>
  Review the provided code for security vulnerabilities.
</Task>

// Audience: Who the output is for (research: CO-STAR, RISEN frameworks)
<Audience expertise="beginner" domain="web development">
  Junior developers new to security concepts
</Audience>
// Output: <audience>\nJunior developers new to security concepts\n</audience>

// Tone: Emotional quality of output (research: CO-STAR, CRISPE frameworks)
<Tone type="friendly" formality="casual">
  Be encouraging and supportive while explaining issues.
</Tone>
// Supported types: formal, casual, friendly, professional, empathetic, assertive, educational
// Output: <tone>\nBe encouraging and supportive...\n</tone>

// SuccessCriteria: Defines what success looks like
<SuccessCriteria>
  <Criterion>Identify all SQL injection risks</Criterion>
  <Criterion>Suggest specific fixes for each issue</Criterion>
  <Criterion priority="high">Response is under 200 words</Criterion>
</SuccessCriteria>

// Constraint: Adds boundaries/rules (research: 35.7% usage)
<Constraint type="must">Always include code examples</Constraint>
<Constraint type="should">Prefer TypeScript over JavaScript</Constraint>
<Constraint type="must-not">Do not suggest deprecated APIs</Constraint>
// Types: must, should, must-not (research: positive framing preferred)

// Format: Specifies output format (research: 39.7% usage)
<Format type="json" schema={mySchema} />
<Format type="markdown" template="## Summary\n{content}" />
<Format type="code" language="typescript" />
<Format type="list" style="numbered" />
```

### Example Components

```tsx
// Example: Provides input/output examples (research: 19.9% usage, all vendors recommend)
<Example>
  <Example.Input>Calculate 15% of 200</Example.Input>
  <Example.Output>30</Example.Output>
</Example>

// Examples: Groups multiple examples
<Examples>
  <Example>...</Example>
  <Example>...</Example>
</Examples>
// Note: Research shows models have recency bias - order matters
```

### Reasoning Components

```tsx
// Steps: Encourages step-by-step thinking (research: 27.5% usage)
<Steps>
  <Step number={1}>Parse the input</Step>
  <Step number={2}>Validate the data</Step>
  <Step number={3}>Process and return</Step>
</Steps>
```

### Data Components

```tsx
// Data: Embeds data with optional formatting
<Data name="users" format="json">
  {JSON.stringify(users, null, 2)}
</Data>

// Code: Embeds code with language hint
<Code language="typescript" filename="example.ts">
  {sourceCode}
</Code>

// File: Embeds file contents
<File path="./config.json" />
```

### Utility Components

Components that generate dynamic values. These values are also available in `context.env.runtime` for components that need programmatic access.

```tsx
// UUID: Generate a unique identifier
<UUID />
// Output: 550e8400-e29b-41d4-a716-446655440000

// Timestamp: Current Unix timestamp
<Timestamp />
// Output: 1705942800

// DateTime: Current date and time
<DateTime />
// Output: 2024-01-22T15:30:00.000Z

// DateTime with format
<DateTime format="YYYY-MM-DD" />
// Output: 2024-01-22

<DateTime format="HH:mm:ss" />
// Output: 15:30:00

// Date: Current date only
<Date />
// Output: 2024-01-22

// Time: Current time only
<Time />
// Output: 15:30:00

// Hostname: Current machine hostname
<Hostname />
// Output: my-laptop.local

// Username: Current user
<Username />
// Output: alice

// Cwd: Current working directory
<Cwd />
// Output: /home/alice/projects/my-app
```

#### Usage in Prompts

```tsx
<Prompt name="code-review">
  <Context>
    Review requested by <Username /> on <DateTime format="YYYY-MM-DD" />
    from machine <Hostname />.
  </Context>
  <Task>Review the following code...</Task>
</Prompt>
// Output:
// <context>
// Review requested by alice on 2024-01-22
// from machine my-laptop.local.
// </context>
```

#### Accessing Runtime Values in Components

Components can also access these values programmatically:

```typescript
const MyComponent = defineComponent({
  name: "MyComponent",
  render: (props, context) => {
    const { hostname, username, datetime } = context.env.runtime;
    return `Generated by ${username}@${hostname} at ${datetime}`;
  },
});
```

### Control Flow Components

#### Conditional Rendering with `<If>`

The `<If>` component uses **Excel formula syntax** for conditions, making it accessible to non-technical users familiar with spreadsheets. Formulas are evaluated using [hot-formula-parser](https://www.npmjs.com/package/hot-formula-parser).

```tsx
// Basic comparison
<If when='=userType="admin"'>
  <Ask.Text name="adminCode" label="Enter admin code" />
</If>

// Numeric comparison
<If when='=count>5'>
  <Task>Process the batch of items</Task>
</If>

// Logical AND/OR
<If when='=AND(count>5, userType="admin")'>
  <Ask.Text name="batchApproval" label="Approve batch processing?" />
</If>

<If when='=OR(priority="high", deadline<TODAY())'>
  <Context>This is an urgent request.</Context>
</If>

// NOT and ISBLANK (empty check)
<If when='=NOT(ISBLANK(notes))'>
  <Context>Additional notes: {inputs.notes}</Context>
</If>

// Nested logic
<If when='=AND(userType="admin", OR(priority="high", escalated=TRUE))'>
  <Task>Handle escalated admin request</Task>
</If>
```

**Supported Excel Functions:**

| Category | Functions |
|----------|-----------|
| **Logical** | `AND(a, b, ...)`, `OR(a, b, ...)`, `NOT(a)` |
| **Comparison** | `=`, `<>`, `>`, `<`, `>=`, `<=` |
| **Empty checks** | `ISBLANK(value)`, `NOT(ISBLANK(value))` |
| **Text** | `LEN(text)`, `CONTAINS(text, substring)`, `STARTSWITH(text, prefix)`, `ENDSWITH(text, suffix)` |
| **Type checks** | `ISNUMBER(value)`, `ISTEXT(value)` |
| **Date** | `TODAY()`, `NOW()` |

**For power users:** Full JavaScript expressions are available when needed:

```tsx
// Complex logic that exceeds Excel formula capabilities
<If when={items.filter(i => i.priority > 3).length >= 2}>
  <Task>Multiple high-priority items detected</Task>
</If>
```

#### Loops with `<ForEach>`

```tsx
// Simple loop - items reference, implicit "item" variable
<ForEach items="tasks">
  <Task>{item.description}</Task>
</ForEach>

// With explicit variable name
<ForEach items="tasks" as="task">
  <Task>{task.description}</Task>
</ForEach>

// For power users: JS expression for filtering/mapping
<ForEach items={tasks.filter(t => t.priority > 3)} as="task">
  <Task priority={task.priority}>{task.description}</Task>
</ForEach>
```

### Uses Component

The `<Uses>` component declares module dependencies at the file level. It enables portable, self-contained prompt files.

```xml
<Uses src="@acme/components" />
<Uses src="https://cdn.example.com/utils.js" />

<Prompt name="support">
  <AcmeHeader />
  <Role>Support agent</Role>
</Prompt>
```

#### Uses Props Interface

```typescript
// src/components/meta/Uses.tsx

export interface UsesProps {
  /** Module source: npm package, URL, git reference, or local path */
  src: string;
}
```

#### Source Formats

| Format | Example |
|--------|---------|
| npm package | `<Uses src="@acme/components" />` |
| npm with version | `<Uses src="@acme/components@1.0.0" />` |
| URL | `<Uses src="https://cdn.example.com/components.js" />` |
| GitHub | `<Uses src="github:acme/components#v1.0.0" />` |
| Local (CLI only) | `<Uses src="./my-components/" />` |

#### Uses Behavior

The `<Uses>` component is processed during file parsing, before prompt rendering:

1. **File parsing:** Parser extracts all `<Uses>` elements from the file
2. **Dependency resolution:** Each source is resolved to a loadable URL
3. **Module loading:** Dependencies are loaded (with deduplication)
4. **Component registration:** Components from loaded modules are registered
5. **Prompt rendering:** Prompts can now use the loaded components

```typescript
// Internal processing (simplified)
async function processPromptFile(content: string): Promise<ParsedFile> {
  const ast = parseXml(content);

  // Extract <Uses> declarations
  const uses = ast.filter(node => node.type === 'Uses');
  const prompts = ast.filter(node => node.type === 'Prompt');

  // Load declared dependencies
  for (const use of uses) {
    await moduleLoader.load(use.props.src);
  }

  return { uses, prompts };
}
```

#### When Uses is Optional

`<Uses>` is **optional** - it's only needed for portability. If modules are already installed/loaded by the consuming application, prompts work without it:

```xml
<!-- This works if @acme/components is already loaded -->
<Prompt name="support">
  <AcmeHeader />
  <Role>Support agent</Role>
</Prompt>
```

When a component is not found and no `<Uses>` declares it, the runtime provides a helpful error:

```
Error: Component "AcmeHeader" not found.

This component is available in:
  - @acme/components (npm)

To fix, either:
  1. Add <Uses src="@acme/components" /> to your prompt file
  2. Run: pt install @acme/components
```

---

### Scope Resolution Components

These components control how component names are resolved to definitions. See [Design Decisions](#design-decisions) for rationale.

```tsx
// Scope: Resolve children from a specific package
// Use when there are naming conflicts between packages
<Scope from="@acme/prompts">
  <Header>This Header comes from @acme/prompts</Header>
  <Footer>This Footer also from @acme/prompts</Footer>
</Scope>

// Nested scopes work as expected
<Scope from="@acme/prompts">
  <Header>Acme header</Header>
  <Scope from="@corp/utils">
    <Widget>Corp widget</Widget>
  </Scope>
  <Footer>Acme footer</Footer>
</Scope>

// Alternative: scope prop for one-off resolution
<Header scope="@acme/prompts">Acme header</Header>
<Header scope="@corp/prompts">Corp header</Header>
```

#### Scope Props Interface

```typescript
// src/components/control/Scope.tsx

export interface ScopeProps {
  /** Package name to resolve components from */
  from: string;
  /** Children to render with this scope */
  children: PuptNode;
}
```

#### Scope Implementation

```typescript
const Scope = defineComponent({
  name: "Scope",
  props: z.object({
    from: z.string(),
    children: z.any(),
  }),
  render: ({ from, children }, context, renderChild) => {
    // Get the scope for the specified package
    const packageScope = context.scopeLoader.getPackageScope(from);
    if (!packageScope) {
      throw new Error(`Package "${from}" not loaded. Add it to your Pupt modules config.`);
    }

    // Render children with the new scope
    const childContext = { ...context, scope: packageScope };
    return renderChild(children, childContext);
  },
});
```

#### When to Use Scope

| Situation | Solution |
|-----------|----------|
| No conflicts | Just use `<Header>` - resolved from default scope |
| Multiple packages define same component | Wrap with `<Scope from="@pkg">` |
| One-off from different package | Use `scope` prop: `<Header scope="@pkg">` |
| Third-party prompt uses own components | Automatic - package scope derived from package.json |

### Post-Execution Components

Components that declare actions to be performed by the higher-level tool (like a CLI) after the prompt has been executed. These components do NOT contribute to the rendered text output - they only populate the `postExecution` array in the `RenderResult`.

#### PostExecution Container

The `<PostExecution>` wrapper collects action components and registers them in the render context.

```tsx
<Prompt name="code-review">
  <Ask.File name="outputFile" label="Select output file" />
  <Task>Write a code review to the file</Task>

  <PostExecution>
    <ReviewFile input="outputFile" />
  </PostExecution>
</Prompt>
```

Multiple `<PostExecution>` blocks in a prompt are merged:

```tsx
<Prompt name="multi-action">
  <PostExecution>
    <ReviewFile input="file1" />
  </PostExecution>

  <Task>...</Task>

  <PostExecution>
    <OpenUrl url="https://docs.example.com" />
  </PostExecution>
</Prompt>
// Result: postExecution contains both actions
```

#### Action Components

**ReviewFile** - Opens a file for review after execution

```tsx
interface ReviewFileProps {
  /** Name of an Ask.File or Ask.Path input to review */
  input: string;
}

<PostExecution>
  <ReviewFile input="outputFile" />
</PostExecution>
```

**OpenUrl** - Opens a URL after execution

```tsx
interface OpenUrlProps {
  /** Name of an input containing the URL */
  input?: string;
  /** Literal URL to open */
  url?: string;
}

// Using input reference
<PostExecution>
  <OpenUrl input="docsUrl" />
</PostExecution>

// Using literal URL
<PostExecution>
  <OpenUrl url="https://example.com/docs" />
</PostExecution>
```

**RunCommand** - Runs a shell command after execution

```tsx
interface RunCommandProps {
  /** Command to execute */
  command: string;
}

<PostExecution>
  <RunCommand command="npm test" />
</PostExecution>
```

#### PostExecution Implementation

```typescript
// src/components/post-execution/PostExecution.tsx

const PostExecution = defineComponent({
  name: "PostExecution",
  render: ({ children }, context, renderChild) => {
    // Process children to collect actions
    // Children (ReviewFile, OpenUrl, etc.) push to context.postExecution
    renderChild(children, context);
    return "";  // No text contribution
  },
});

// src/components/post-execution/ReviewFile.tsx

const ReviewFile = defineComponent({
  name: "ReviewFile",
  props: z.object({
    input: z.string(),
  }),
  render: ({ input }, context) => {
    const file = context.inputs.get(input);
    if (typeof file === "string") {
      context.postExecution.push({ type: "reviewFile", file });
    }
    return "";  // No text contribution
  },
});

// src/components/post-execution/OpenUrl.tsx

const OpenUrl = defineComponent({
  name: "OpenUrl",
  props: z.object({
    input: z.string().optional(),
    url: z.string().optional(),
  }),
  render: ({ input, url }, context) => {
    const resolvedUrl = input ? context.inputs.get(input) : url;
    if (typeof resolvedUrl === "string") {
      context.postExecution.push({ type: "openUrl", url: resolvedUrl });
    }
    return "";  // No text contribution
  },
});

// src/components/post-execution/RunCommand.tsx

const RunCommand = defineComponent({
  name: "RunCommand",
  props: z.object({
    command: z.string(),
  }),
  render: ({ command }, context) => {
    context.postExecution.push({ type: "runCommand", command });
    return "";  // No text contribution
  },
});
```

#### RenderContext Update

The render context includes a `postExecution` array for collecting actions:

```typescript
export interface RenderContext {
  // ...existing fields

  /** Collected post-execution actions */
  postExecution: PostExecutionAction[];
}
```

#### CLI Usage Example

```typescript
import { Pupt, createInputCollector } from "pupt-lib";

const pupt = new Pupt({ modules: ["./prompts"] });
await pupt.init();
const prompt = pupt.getPrompt("my-prompt");

// Collect inputs
const collector = createInputCollector();
const inputs = await collector.collectAll(prompt.element, askUser);

// Render returns structured result
const result = prompt.render({ inputs });

// Use the text
await sendToLLM(result.text);

// Handle post-execution actions
for (const action of result.postExecution) {
  switch (action.type) {
    case "reviewFile":
      await openInEditor(action.file);
      break;
    case "openUrl":
      await openBrowser(action.url);
      break;
    case "runCommand":
      await exec(action.command);
      break;
  }
}
```

### User Input Components (Ask.*)

User input components support two syntaxes:
- **Child elements** (simple, non-technical users) — Options as nested `<Option>` elements
- **JS attributes** (advanced, dynamic data) — Options as JavaScript arrays

#### Ask.Text: Single-line text input

```tsx
<Ask.Text
  name="projectName"
  label="What is your project name?"
  placeholder="my-project"
  required
/>
```

#### Ask.Editor: Multi-line editor input

```tsx
<Ask.Editor
  name="codeToReview"
  label="Paste the code you want reviewed"
  language="typescript"
/>
```

#### Ask.Select: Single selection

**Simple syntax (child elements):**

```tsx
<Ask.Select name="framework" label="Which framework are you using?">
  <Option value="react">React</Option>
  <Option value="vue">Vue</Option>
  <Option value="angular">Angular</Option>
</Ask.Select>
```

**Advanced syntax (JS attributes):**

```tsx
<Ask.Select
  name="framework"
  label="Which framework are you using?"
  options={frameworks.map(f => ({ value: f.id, label: f.name }))}
/>

#### Ask.MultiSelect: Multiple selection

**Simple syntax (child elements):**

```tsx
<Ask.MultiSelect name="features" label="Which features do you need?" min="1" max="5">
  <Option value="auth">Authentication</Option>
  <Option value="api">REST API</Option>
  <Option value="db">Database</Option>
  <Option value="ui">UI Components</Option>
</Ask.MultiSelect>
```

**Advanced syntax (JS attributes):**

```tsx
<Ask.MultiSelect
  name="features"
  label="Which features do you need?"
  options={availableFeatures}
  min={1}
  max={5}
/>

// Ask.Confirm: Yes/no confirmation
<Ask.Confirm
  name="includeTests"
  label="Should I include test examples?"
  default={true}
/>

// Ask.File: File selection
<Ask.File
  name="sourceFiles"
  label="Select the source files to analyze"
  extensions={[".ts", ".tsx"]}
  multiple
  includeContents
/>

// Ask.ReviewFile: File selection with automatic post-execution review
// Syntactic sugar that combines Ask.File with PostExecution ReviewFile
<Ask.ReviewFile
  name="outputFile"
  label="Select file to review after execution"
  extensions={[".md", ".txt"]}
/>
// Equivalent to:
// <>
//   <Ask.File name="outputFile" label="..." extensions={[".md", ".txt"]} />
//   <PostExecution>
//     <ReviewFile input="outputFile" />
//   </PostExecution>
// </>

// Ask.Number: Numeric input
<Ask.Number
  name="maxResults"
  label="Maximum number of results"
  min={1}
  max={100}
  default={10}
/>

// Ask.Choice: Binary choice with custom labels (different from Confirm)
<Ask.Choice
  name="approach"
  label="Which approach should we take?"
  options={[
    { value: "refactor", label: "Refactor existing code" },
    { value: "rewrite", label: "Rewrite from scratch" }
  ]}
/>

#### Ask.Rating: Numeric scale input

**Simple syntax (child elements):**

```tsx
<Ask.Rating name="priority" label="How urgent is this issue?" min="1" max="5">
  <Label value="1">Low</Label>
  <Label value="3">Medium</Label>
  <Label value="5">Critical</Label>
</Ask.Rating>
```

**Advanced syntax (JS attributes):**

```tsx
<Ask.Rating
  name="priority"
  label="How urgent is this issue?"
  min={1}
  max={5}
  labels={{ 1: "Low", 3: "Medium", 5: "Critical" }}
/>

// Ask.Date: Date/time input
<Ask.Date
  name="deadline"
  label="When is this needed by?"
  includeTime={false}
  minDate="today"
/>

// Ask.Secret: Sensitive input (API keys, passwords - masked)
<Ask.Secret
  name="apiKey"
  label="Enter your API key"
  description="This will not be displayed or logged"
/>

// Ask.Path: File/directory path input
<Ask.Path
  name="projectRoot"
  label="Select your project directory"
  type="directory"
  mustExist={true}
/>
```

---

## API Design

### API Summary

This table provides a comprehensive overview of all public APIs exposed by pupt-lib.

#### Primary API (Application Entry Points)

| Export | Type | Description |
|--------|------|-------------|
| `Pupt` | Class | Main entry point for CLI and browser apps. Handles module loading, deduplication, and prompt discovery. |
| `Pupt.init()` | Method | Loads all configured modules, resolves dependencies, generates browser import maps. Must be called before using prompts. |
| `Pupt.getPrompts(filter?)` | Method | Returns all discovered prompts, optionally filtered by tags. |
| `Pupt.getPrompt(name)` | Method | Returns a specific prompt by name, or undefined if not found. |
| `Pupt.loadModule(source)` | Method | Loads an additional module after init. Returns `PuptLibrary` metadata. |
| `Pupt.hasComponent(name)` | Method | Checks if a component is registered and available. |
| `Pupt.getRegistry()` | Method | Returns the component registry for advanced use cases. |
| `Pupt.searchPrompts(query, options?)` | Method | Fuzzy search prompts by name, description, tags, or content. Returns ranked results. |
| `Pupt.getTags()` | Method | Returns all unique tags across all loaded prompts. |
| `Pupt.getPromptsByTag(tag)` | Method | Returns all prompts with the specified tag. |

#### Core Rendering

| Export | Type | Description |
|--------|------|-------------|
| `render(element, options?)` | Function | Synchronously renders a PuptElement tree to `RenderResult` containing text and post-execution actions. |
| `renderAsync(element, options?)` | Function | Asynchronously renders a PuptElement tree, resolving any Promise children. |
| `createPrompt(options)` | Function | Creates a prompt element programmatically (alternative to JSX). |

#### Input Collection

| Export | Type | Description |
|--------|------|-------------|
| `createInputIterator(options?)` | Function | Creates a low-level iterator for depth-first input collection with `start/current/submit/advance` API. |
| `createInputCollector(options?)` | Function | Creates a higher-level input collector with automatic retry loop and validation. |
| `InputIterator` | Interface | Low-level input iteration: `start()`, `current()`, `submit(value)`, `advance()`, `isDone()`. |
| `InputCollector` | Interface | Higher-level API: `collect(element, handler)` returns all collected inputs. |

#### Component System

| Export | Type | Description |
|--------|------|-------------|
| `Component<Props>` | Class | Base class for custom components. Extend this and implement `render()`. |
| `defineComponent(options)` | Function | Functional API for defining components with Zod schema validation. |
| `createRegistry()` | Function | Creates a new component registry (for testing or isolation). |
| `defaultRegistry` | Const | The default global component registry where built-in components are registered. |
| `isComponentClass(value)` | Function | Type guard to check if a value is a Component class (uses `Symbol.for` for cross-bundle detection). |

#### Scope System

| Export | Type | Description |
|--------|------|-------------|
| `Scope` | Class | Represents a component namespace. Resolves component names to definitions. |
| `createScope(name, parent?)` | Function | Creates a new scope, optionally inheriting from a parent scope. |
| `builtinScope` | Const | The built-in scope containing all default components (Role, Task, etc.). |
| `ScopeLoader` | Class | Loads packages, walks dependencies, and builds scope chains. |

#### Environment & Configuration

| Export | Type | Description |
|--------|------|-------------|
| `createEnvironment(model, options?)` | Function | Creates an environment context configured for a specific LLM model. |
| `DEFAULT_ENVIRONMENT` | Const | Default environment configuration (Claude, XML output format). |
| `createRuntimeConfig()` | Function | Creates runtime config with hostname, username, cwd, timestamps. |

#### Search & Discovery

| Export | Type | Description |
|--------|------|-------------|
| `createSearchEngine(config?)` | Function | Creates a fuzzy search engine for discovering prompts across libraries. |
| `SearchEngine` | Interface | Search API: `index(prompts)`, `search(query, options)`, `getByTag(tag)`, `getAllTags()`. |

#### JSX Runtime

| Export | Type | Description |
|--------|------|-------------|
| `jsx(type, props, key)` | Function | JSX runtime function for single-child elements. Auto-imported by Babel. |
| `jsxs(type, props, key)` | Function | JSX runtime function for multi-child elements. Auto-imported by Babel. |
| `Fragment` | Symbol | Fragment component for grouping without wrapper element. |

#### Transformation

| Export | Type | Description |
|--------|------|-------------|
| `Transformer` | Class | Transforms `.tsx` and `.prompt` files to executable code. |
| `puptBabelPreset` | Const | Babel preset for transforming pupt-lib JSX files. |

#### Validation

| Export | Type | Description |
|--------|------|-------------|
| `createValidator(schema)` | Function | Creates a validator function from a Zod schema for input validation. |

#### Types

| Export | Type | Description |
|--------|------|-------------|
| `PuptElement` | Type | Represents a JSX element with type, props, and children. |
| `PuptNode` | Type | Union type: `PuptElement \| string \| number \| null \| PuptNode[]`. |
| `RenderContext` | Interface | Context passed to components during rendering (scope, inputs, env). |
| `RenderOptions` | Interface | Options for `render()`: inputs, indent, trim, registry, env. |
| `RenderResult` | Interface | Result of rendering: `{ text: string, postExecution: PostExecutionAction[] }`. |
| `InputRequirement` | Interface | Describes a user input: name, type, label, validation, options. |
| `EnvironmentContext` | Interface | Full environment config: LLM settings, output format, runtime values. |
| `LlmConfig` | Interface | LLM configuration: model, provider, temperature, maxTokens. |
| `PuptConfig` | Interface | Configuration for `Pupt` class: modules, prompts, env. |
| `PuptLibrary` | Interface | Loaded library metadata: name, version, components, prompts, capabilities. |
| `DiscoveredPrompt` | Interface | A prompt ready to render: name, description, tags, element, render(), getInputIterator(). |
| `SearchablePrompt` | Interface | Prompt metadata for search indexing. |
| `SearchResult` | Interface | Search result with prompt, score, and matched fields. |
| `PostExecutionAction` | Type | Actions after execution: `reviewFile`, `openUrl`, `runCommand`. |

#### Built-in Components

| Component | Category | Description |
|-----------|----------|-------------|
| `<Prompt>` | Container | Top-level prompt container with name, description, tags. |
| `<Fragment>` | Container | Groups children without adding wrapper text. |
| `<Role>` | Structural | Defines the AI's role/persona. |
| `<Task>` | Structural | Specifies what the AI should do. |
| `<Context>` | Structural | Provides background information. |
| `<Constraints>` | Structural | Lists limitations or rules. |
| `<Format>` | Structural | Specifies desired output format. |
| `<Audience>` | Structural | Describes the target audience. |
| `<Tone>` | Structural | Sets the communication tone. |
| `<SuccessCriteria>` | Structural | Defines what success looks like. |
| `<Example>` | Examples | Single input/output example for few-shot learning. |
| `<Examples>` | Examples | Container for multiple examples. |
| `<Steps>` | Reasoning | Chain-of-thought reasoning scaffold. |
| `<Step>` | Reasoning | Individual step in reasoning chain. |
| `<Data>` | Data | Embeds structured data in prompt. |
| `<Json>` | Data | Formats data as JSON. |
| `<Xml>` | Data | Formats data as XML. |
| `<Code>` | Data | Embeds code with language hint. |
| `<If>` | Control Flow | Conditional rendering with Excel-style formulas. |
| `<ForEach>` | Control Flow | Iterates over arrays. |
| `<Uses>` | Meta | Declares module dependencies (file-level). |
| `<Scope>` | Meta | Resolves component names from specific package. |
| `<PostExecution>` | Actions | Container for post-execution actions. |
| `<ReviewFile>` | Actions | Opens a file for review after execution. |
| `<OpenUrl>` | Actions | Opens a URL after execution. |
| `<RunCommand>` | Actions | Runs a command after execution. |
| `<UUID>` | Utility | Generates a unique identifier. |
| `<Timestamp>` | Utility | Current Unix timestamp. |
| `<DateTime>` | Utility | Formatted date/time string. |
| `<Hostname>` | Utility | Current machine hostname. |
| `<Username>` | Utility | Current user's username. |
| `<Cwd>` | Utility | Current working directory. |
| `<Ask.Text>` | Input | Single-line text input. |
| `<Ask.Editor>` | Input | Multi-line text editor. |
| `<Ask.Select>` | Input | Single-choice selection. |
| `<Ask.MultiSelect>` | Input | Multiple-choice selection. |
| `<Ask.Confirm>` | Input | Yes/no confirmation. |
| `<Ask.File>` | Input | File path selection. |
| `<Ask.Number>` | Input | Numeric input with min/max. |
| `<Ask.Date>` | Input | Date selection. |
| `<Ask.Secret>` | Input | Password/secret input (masked). |
| `<Ask.Path>` | Input | Directory path selection. |

---

### Main Exports

```typescript
// src/index.ts

// Core rendering
export { render, renderAsync } from "./render";
export { createPrompt } from "./create-prompt";

// JSX Runtime (auto-imported by Babel)
export { jsx, jsxs, Fragment } from "./jsx-runtime";

// Types
export type {
  PuptElement,
  PuptNode,
  ComponentProps,
  RenderContext,
  ComponentDefinition,
  InputRequirement,
  EnvironmentContext,
  LlmConfig,
  CodeConfig,
  OutputConfig,
  SearchablePrompt,
  SearchResult,
  SearchOptions,
} from "./types";

// Environment helpers
export { DEFAULT_ENVIRONMENT, createEnvironment } from "./types/context";

// Primary API
export { Pupt, type DiscoveredPrompt } from "./api";

// Services
export { createInputIterator, type InputIterator } from "./services/input-iterator";
export { createInputCollector, type InputCollector } from "./services/input-collector";
export { ScopeLoader } from "./services/scope-loader";
export { Scope, createScope } from "./services/scope";
export { Transformer } from "./services/transformer";
export { createRegistry, defaultRegistry, type ComponentRegistry } from "./services/component-registry";
export { createSearchEngine, type SearchEngine } from "./services/search-engine";

// Default Components
export * from "./components";

// Utilities
export { defineComponent } from "./utils/define-component";
export { createValidator } from "./utils/validation";
```

### Module Loading API

pupt-lib provides a unified `Pupt` class for loading modules and prompts that works in both CLI (Node.js) and browser environments.

#### Pupt Class

The main entry point for applications using pupt-lib:

```typescript
// src/api.ts

import { Pupt } from 'pupt-lib';

// 1. Create instance with module sources
const pupt = new Pupt({
  modules: [
    '@acme/prompts',                    // npm package
    'github:corp/prompts#v1.0.0',       // git
    'https://example.com/prompts.js',   // CDN/URL
    './local-prompts/',                 // local (CLI only)
  ],
});

// 2. Initialize (loads all modules, resolves dependencies, deduplicates)
await pupt.init();

// 3. List available prompts
const prompts = pupt.getPrompts();
// → [{ name: 'support-ticket', tags: ['support'], ... }, ...]

// 4. Get a specific prompt
const prompt = pupt.getPrompt('support-ticket');

// 5. Collect inputs (if any)
const inputs = await prompt.collectInputs({
  values: { customerId: '12345' },      // Pre-supply known values
  onInput: (req) => askUser(req),       // Handler for interactive collection
});

// 6. Render
const result = await prompt.render({ inputs });
// → { text: "...", postExecution: [...] }
```

#### Pupt Configuration

```typescript
export interface PuptConfig {
  /** Module sources to load (npm, URL, git, local path) */
  modules?: string[];

  /** Prompt file sources (glob patterns for .prompt files) */
  prompts?: string[];

  /** Environment configuration */
  env?: Partial<EnvironmentContext>;
}

export class Pupt {
  constructor(config?: PuptConfig);

  /** Initialize: load all modules, resolve dependencies */
  init(): Promise<void>;

  /** Get all discovered prompts */
  getPrompts(filter?: { tags?: string[] }): DiscoveredPrompt[];

  /** Get a specific prompt by name */
  getPrompt(name: string): DiscoveredPrompt | undefined;

  /** Fuzzy search prompts by name, description, tags, or content */
  searchPrompts(query: string, options?: SearchOptions): SearchResult[];

  /** Get all unique tags across all loaded prompts */
  getTags(): string[];

  /** Get all prompts with a specific tag */
  getPromptsByTag(tag: string): DiscoveredPrompt[];

  /** Load additional modules after init */
  loadModule(source: string): Promise<PuptLibrary>;

  /** Check if a component is available */
  hasComponent(name: string): boolean;

  /** Get component registry (for advanced use) */
  getRegistry(): ComponentRegistry;
}
```

#### Source Format Resolution

The `Pupt` class accepts multiple source formats:

| Format | Example | Resolution |
|--------|---------|------------|
| npm package | `@acme/prompts` | Resolved via Node.js or esm.sh |
| npm with version | `@acme/prompts@1.0.0` | Pinned version |
| URL | `https://cdn.example.com/lib.js` | Direct fetch |
| GitHub | `github:acme/prompts#v1.0.0` | GitHub raw URL |
| Local path | `./my-prompts/` | File system (CLI only) |

#### Module Deduplication

The loader tracks loaded modules to prevent duplicate loading:

```typescript
class ModuleLoader {
  private loaded = new Map<string, LoadedModule>();
  private loading = new Map<string, Promise<LoadedModule>>();

  async load(source: string): Promise<LoadedModule> {
    // Already loaded? Return cached
    if (this.loaded.has(source)) {
      return this.loaded.get(source)!;
    }

    // Currently loading? Return pending promise (handles concurrent requests)
    if (this.loading.has(source)) {
      return this.loading.get(source)!;
    }

    // Load dependencies first, then this module
    const promise = this.doLoad(source);
    this.loading.set(source, promise);

    const module = await promise;
    this.loaded.set(source, module);
    this.loading.delete(source);

    return module;
  }
}
```

#### Browser Module Loading

For browser environments, pupt-lib generates an import map before loading modules:

```typescript
// Browser setup (handled internally by Pupt)
async function setupBrowserModules(sources: string[]): Promise<void> {
  // 1. Resolve dependency tree for all sources
  const allDeps = await resolveDependencyTree(sources);

  // 2. Generate import map
  const importMap = {
    imports: {
      'pupt-lib': 'https://esm.sh/pupt-lib@1.0.0',
      ...Object.fromEntries(
        allDeps.map(([name, version]) => [name, `https://esm.sh/${name}@${version}`])
      ),
    },
  };

  // 3. Inject import map into document
  const script = document.createElement('script');
  script.type = 'importmap';
  script.textContent = JSON.stringify(importMap);
  document.head.appendChild(script);
}
```

This ensures all modules share a single copy of `pupt-lib` and other dependencies.

#### PuptLibrary Interface

```typescript
export interface PuptLibrary {
  /** Library name (from metadata or derived from source) */
  name: string;
  /** Library version */
  version: string;
  /** Dependencies that were loaded */
  dependencies: string[];
  /** Source this was loaded from */
  source: string;
  /** Discovered components (classes extending Component) */
  components: Record<string, ComponentClass>;
  /** Discovered prompts (JSX elements with <Prompt> root) */
  prompts: Record<string, PromptElement>;
  /** Capabilities required (filesystem, network, etc.) */
  capabilities?: string[];
}
```

#### How Scoping Works

| Source Type | Scope Contains |
|-------------|----------------|
| npm package (`@acme/prompts`) | Built-ins + package's own components + components from its dependencies |
| Local directory (`./prompts`) | Built-ins + all components from all loaded packages |

```typescript
const pupt = new Pupt({
  modules: [
    '@acme/prompts',    // @acme prompts use @acme's scope
    '@corp/prompts',    // @corp prompts use @corp's scope
    './my-prompts',     // local prompts use combined scope
  ],
});
await pupt.init();
const prompts = pupt.getPrompts();

// @acme/prompts/support.tsx → rendered with @acme's scope
// @corp/prompts/help.tsx    → rendered with @corp's scope
// ./my-prompts/custom.tsx   → rendered with combined scope (can use both)
```

#### Conflict Resolution

If multiple packages define the same component name (e.g., both define `<Header>`):

- **Package prompts:** No conflict - each uses its own scope
- **Local prompts:** Use `<Scope from="@pkg">` to disambiguate

```tsx
// ./my-prompts/mixed.tsx
export default (
  <Prompt name="mixed">
    <Scope from="@acme/prompts">
      <Header>Acme header</Header>
    </Scope>
    <Scope from="@corp/prompts">
      <Header>Corp header</Header>
    </Scope>
  </Prompt>
);
```

### Core Functions

```typescript
// src/render.ts

export interface RenderOptions {
  /** Pre-supplied input values */
  inputs?: Map<string, unknown> | Record<string, unknown>;
  /** Indentation string (default: 2 spaces) */
  indent?: string;
  /** Whether to trim whitespace (default: true) */
  trim?: boolean;
  /** Custom component registry */
  registry?: ComponentRegistry;
  /** Environment configuration for LLM/output targeting */
  env?: Partial<EnvironmentContext>;
}

/**
 * Actions to perform after prompt execution by the higher-level tool.
 * These are collected from <PostExecution> components during render.
 */
export type PostExecutionAction =
  | { type: "reviewFile"; file: string }
  | { type: "openUrl"; url: string }
  | { type: "runCommand"; command: string };

/**
 * Result of rendering a prompt.
 */
export interface RenderResult {
  /** The rendered prompt text */
  text: string;

  /** Actions to perform after prompt execution */
  postExecution: PostExecutionAction[];
}

/**
 * Render a PuptElement tree to a RenderResult
 */
export function render(element: PuptElement, options?: RenderOptions): RenderResult;

/**
 * Async render that resolves any Promise children
 */
export async function renderAsync(
  element: PuptElement,
  options?: RenderOptions
): Promise<RenderResult>;
```

```typescript
// src/create-prompt.ts

export interface CreatePromptOptions {
  /** Search paths for third-party libraries */
  libraryPaths?: string[];
  /** Whether to include node_modules in search */
  includeNodeModules?: boolean;
  /** Custom Babel plugins */
  babelPlugins?: string[];
}

/**
 * Create a prompt from a JSX/TSX file path
 */
export async function createPrompt(
  filePath: string,
  options?: CreatePromptOptions
): Promise<{
  /** The rendered prompt text */
  prompt: string;
  /** Input requirements (if any Ask.* components) */
  inputs: InputRequirement[];
  /** Function to render with input values */
  renderWith: (values: Record<string, unknown>) => string;
}>;

/**
 * Create a prompt from JSX/TSX source string
 */
export async function createPromptFromSource(
  source: string,
  options?: CreatePromptOptions & { filename?: string }
): Promise<{
  prompt: string;
  inputs: InputRequirement[];
  renderWith: (values: Record<string, unknown>) => string;
}>;
```

### Component Definition Helper

```typescript
// src/utils/define-component.ts

import { z } from "zod";

/**
 * Helper to define a custom component with validation
 */
export function defineComponent<P extends z.ZodType>(options: {
  name: string;
  props: P;
  render: (props: z.infer<P>, context: RenderContext) => string;
}): ComponentDefinition;

// Usage example:
const MyComponent = defineComponent({
  name: "MyComponent",
  props: z.object({
    title: z.string(),
    items: z.array(z.string()).optional(),
  }),
  render: ({ title, items }, context) => {
    let output = `## ${title}\n`;
    if (items) {
      output += items.map(item => `- ${item}`).join("\n");
    }
    return output;
  },
});
```

---

## File Structure

```
pupt-lib/
├── src/
│   ├── index.ts                    # Main exports
│   ├── api.ts                      # Primary API: Pupt class
│   ├── render.ts                   # Core rendering logic (returns RenderResult)
│   ├── create-prompt.ts            # Low-level prompt creation
│   │
│   ├── types/
│   │   ├── index.ts                # Type exports
│   │   ├── component.ts            # PuptComponent, PuptElement, PuptNode
│   │   ├── context.ts              # EnvironmentContext, RenderContext
│   │   ├── input.ts                # InputRequirement types
│   │   └── render.ts               # RenderResult, PostExecutionAction
│   │
│   ├── jsx-runtime/
│   │   ├── index.ts                # JSX runtime entry
│   │   ├── jsx-dev-runtime.ts      # Development runtime
│   │   └── types.ts                # JSX types
│   │
│   ├── components/
│   │   ├── index.ts                # Component exports
│   │   ├── structural/
│   │   │   ├── index.ts
│   │   │   ├── Prompt.tsx          # Top-level prompt container
│   │   │   ├── Section.tsx
│   │   │   ├── Role.tsx
│   │   │   ├── Context.tsx
│   │   │   ├── Task.tsx
│   │   │   ├── Audience.tsx
│   │   │   ├── Tone.tsx
│   │   │   ├── SuccessCriteria.tsx
│   │   │   ├── Constraint.tsx
│   │   │   └── Format.tsx
│   │   ├── examples/
│   │   │   ├── index.ts
│   │   │   ├── Example.tsx
│   │   │   └── Examples.tsx
│   │   ├── reasoning/
│   │   │   ├── index.ts
│   │   │   ├── Steps.tsx
│   │   │   └── Step.tsx
│   │   ├── data/
│   │   │   ├── index.ts
│   │   │   ├── Data.tsx
│   │   │   ├── Code.tsx
│   │   │   └── File.tsx
│   │   ├── utility/
│   │   │   ├── index.ts
│   │   │   ├── UUID.tsx
│   │   │   ├── Timestamp.tsx
│   │   │   ├── DateTime.tsx
│   │   │   ├── Date.tsx
│   │   │   ├── Time.tsx
│   │   │   ├── Hostname.tsx
│   │   │   ├── Username.tsx
│   │   │   └── Cwd.tsx
│   │   ├── control/
│   │   │   ├── index.ts
│   │   │   ├── Conditional.tsx
│   │   │   ├── Repeat.tsx
│   │   │   └── Scope.tsx           # Scope resolution for conflicts
│   │   ├── post-execution/
│   │   │   ├── index.ts
│   │   │   ├── PostExecution.tsx   # Container for post-execution actions
│   │   │   ├── ReviewFile.tsx      # Open file for review after execution
│   │   │   ├── OpenUrl.tsx         # Open URL after execution
│   │   │   └── RunCommand.tsx      # Run shell command after execution
│   │   └── ask/
│   │       ├── index.ts            # Ask namespace export
│   │       ├── types.ts            # Input types
│   │       ├── Text.tsx
│   │       ├── Editor.tsx
│   │       ├── Select.tsx
│   │       ├── MultiSelect.tsx
│   │       ├── Confirm.tsx
│   │       ├── Choice.tsx          # Binary choice with custom labels
│   │       ├── Rating.tsx          # Numeric scale (1-5, 1-10)
│   │       ├── Date.tsx            # Date/time input
│   │       ├── Secret.tsx          # Sensitive input (masked)
│   │       ├── Path.tsx            # File/directory path
│   │       ├── File.tsx
│   │       ├── ReviewFile.tsx      # File + automatic PostExecution ReviewFile
│   │       └── Number.tsx
│   │
│   ├── services/
│   │   ├── input-iterator.ts       # Depth-first input iteration
│   │   ├── input-collector.ts      # Input collection convenience wrapper
│   │   ├── scope.ts                # Scope class for component resolution
│   │   ├── scope-loader.ts         # Package.json walking, scope building
│   │   ├── library-loader.ts       # Third-party library loading
│   │   ├── transformer.ts          # Babel transformation
│   │   ├── component-registry.ts   # Component registration
│   │   └── search-engine.ts        # Fuzzy prompt search
│   │
│   ├── babel/
│   │   └── preset.ts               # Babel preset config
│   │
│   ├── types/
│   │   ├── index.ts                # Type exports
│   │   ├── component.ts            # Component types
│   │   ├── context.ts              # Environment context types
│   │   ├── element.ts              # Element types
│   │   └── input.ts                # Input types
│   │
│   └── utils/
│       ├── define-component.ts     # Component helper
│       ├── validation.ts           # Validation utilities
│       └── text.ts                 # Text utilities
│
├── test/
│   ├── setup.ts                    # Test setup
│   ├── unit/
│   │   ├── render.test.ts
│   │   ├── jsx-runtime.test.ts
│   │   ├── components/
│   │   │   ├── structural.test.ts
│   │   │   ├── ask.test.ts
│   │   │   └── ...
│   │   └── services/
│   │       ├── input-iterator.test.ts
│   │       ├── input-collector.test.ts
│   │       ├── scope.test.ts
│   │       ├── scope-loader.test.ts
│   │       ├── library-loader.test.ts
│   │       ├── component-registry.test.ts
│   │       ├── search-engine.test.ts
│   │       └── transformer.test.ts
│   ├── integration/
│   │   ├── full-prompt.test.ts
│   │   └── third-party.test.ts
│   └── fixtures/
│       ├── prompts/
│       │   ├── simple.tsx
│       │   ├── with-inputs.tsx
│       │   └── complex.tsx
│       └── libraries/
│           └── test-lib/
│
├── scripts/
│   └── add-shebang.js              # Build script
│
├── .github/
│   └── workflows/
│       └── ci.yml                  # CI/CD workflow
│
├── .husky/
│   ├── commit-msg
│   ├── prepare-commit-msg
│   └── pre-push
│
├── design/
│   └── pupt-lib-design.md          # This file
│
├── tmp/                            # Temporary files (gitignored)
│
├── package.json
├── tsconfig.json
├── vite.config.ts
├── vitest.config.ts
├── vitest.config.integration.ts
├── eslint.config.mjs
├── knip.json
├── commitlint.config.js
├── .releaserc
└── .gitignore
```

---

## Configuration Files

### package.json

```json
{
  "name": "pupt-lib",
  "version": "0.0.0-development",
  "description": "Programmatic, composable, OOP-empowered AI prompt creation using JSX",
  "type": "module",
  "main": "./dist/index.js",
  "module": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "import": "./dist/index.js"
    },
    "./jsx-runtime": {
      "types": "./dist/jsx-runtime/index.d.ts",
      "import": "./dist/jsx-runtime/index.js"
    },
    "./jsx-dev-runtime": {
      "types": "./dist/jsx-runtime/jsx-dev-runtime.d.ts",
      "import": "./dist/jsx-runtime/jsx-dev-runtime.js"
    }
  },
  "files": [
    "dist"
  ],
  "keywords": [
    "prompt",
    "llm",
    "ai",
    "jsx",
    "template",
    "claude",
    "gpt",
    "gemini"
  ],
  "license": "MIT",
  "engines": {
    "node": ">=20.0.0"
  },
  "scripts": {
    "build": "vite build && tsc --emitDeclarationOnly",
    "dev": "vite build --watch",
    "lint": "eslint src/ test/",
    "lint:fix": "eslint src/ test/ --fix",
    "test": "vitest run",
    "test:unit": "vitest run --config vitest.config.ts",
    "test:integration": "vitest run --config vitest.config.integration.ts",
    "test:watch": "vitest",
    "test:coverage": "vitest run --coverage",
    "prepare": "husky",
    "knip": "knip",
    "commit": "cz"
  },
  "dependencies": {
    "@babel/core": "^7.26.0",
    "@babel/plugin-transform-react-jsx": "^7.25.0",
    "@babel/preset-typescript": "^7.26.0",
    "minisearch": "^7.1.0",
    "zod": "^3.24.0"
  },
  "devDependencies": {
    "@commitlint/cli": "^20.3.0",
    "@commitlint/config-conventional": "^20.3.0",
    "@eslint/js": "^9.39.0",
    "@semantic-release/changelog": "^6.0.0",
    "@semantic-release/git": "^10.0.0",
    "@semantic-release/github": "^11.0.0",
    "@semantic-release/npm": "^13.1.0",
    "@stylistic/eslint-plugin": "^2.12.0",
    "@types/babel__core": "^7.20.0",
    "@types/node": "^22.0.0",
    "@vitest/coverage-v8": "^2.1.0",
    "commitizen": "^4.3.0",
    "cz-conventional-changelog": "^3.3.0",
    "eslint": "^9.17.0",
    "husky": "^9.1.0",
    "knip": "^5.80.0",
    "semantic-release": "^25.0.0",
    "tsx": "^4.19.0",
    "typescript": "^5.7.0",
    "typescript-eslint": "^8.19.0",
    "vite": "^6.0.0",
    "vite-plugin-dts": "^4.5.0",
    "vitest": "^2.1.0"
  },
  "publishConfig": {
    "access": "public",
    "provenance": true
  },
  "config": {
    "commitizen": {
      "path": "./node_modules/cz-conventional-changelog"
    }
  }
}
```

### tsconfig.json

```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "NodeNext",
    "moduleResolution": "NodeNext",
    "strict": true,
    "declaration": true,
    "declarationMap": true,
    "outDir": "./dist",
    "rootDir": "./src",
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "esModuleInterop": true,
    "jsx": "react-jsx",
    "jsxImportSource": "pupt-lib"
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist", "test"]
}
```

### vite.config.ts

```typescript
import { defineConfig } from "vite";
import dts from "vite-plugin-dts";
import { resolve } from "path";

export default defineConfig({
  build: {
    lib: {
      entry: {
        index: resolve(__dirname, "src/index.ts"),
        "jsx-runtime/index": resolve(__dirname, "src/jsx-runtime/index.ts"),
        "jsx-runtime/jsx-dev-runtime": resolve(__dirname, "src/jsx-runtime/jsx-dev-runtime.ts"),
      },
      formats: ["es"],
    },
    rollupOptions: {
      external: [
        "@babel/core",
        "@babel/plugin-transform-react-jsx",
        "@babel/preset-typescript",
        "zod",
        /^node:/,
      ],
    },
    target: "node20",
    minify: false,
  },
  plugins: [
    dts({
      include: ["src/**/*"],
      outDir: "dist",
    }),
  ],
});
```

### vitest.config.ts

```typescript
import { defineConfig } from "vitest/config";

export default defineConfig({
  test: {
    include: ["test/unit/**/*.test.ts"],
    environment: "node",
    setupFiles: ["./test/setup.ts"],
    coverage: {
      provider: "v8",
      reporter: ["text", "json", "html", "lcov"],
      thresholds: {
        statements: 80,
        branches: 75,
        functions: 80,
        lines: 80,
      },
      exclude: [
        "src/index.ts",
        "test/**",
        "**/*.d.ts",
      ],
    },
    globals: true,
  },
});
```

### vitest.config.integration.ts

```typescript
import { defineConfig } from "vitest/config";

export default defineConfig({
  test: {
    include: ["test/integration/**/*.test.ts"],
    environment: "node",
    setupFiles: ["./test/setup.ts"],
    testTimeout: 30000,
    globals: true,
  },
});
```

### eslint.config.mjs

```javascript
import eslint from "@eslint/js";
import tseslint from "typescript-eslint";
import stylistic from "@stylistic/eslint-plugin";

export default tseslint.config(
  eslint.configs.recommended,
  ...tseslint.configs.recommended,
  {
    plugins: {
      "@stylistic": stylistic,
    },
    rules: {
      "@stylistic/indent": ["error", 2],
      "@stylistic/quotes": ["error", "double"],
      "@stylistic/semi": ["error", "always"],
      "@stylistic/comma-dangle": ["error", "always-multiline"],
      "@stylistic/object-curly-spacing": ["error", "always"],
      "@stylistic/array-bracket-spacing": ["error", "never"],
      "@typescript-eslint/no-unused-vars": ["error", { argsIgnorePattern: "^_" }],
      "@typescript-eslint/no-explicit-any": "warn",
      "@typescript-eslint/explicit-function-return-type": "off",
    },
  },
  {
    ignores: ["dist/", "node_modules/", "coverage/", "**/*.js", "**/*.mjs", "tmp/"],
  }
);
```

### knip.json

```json
{
  "entry": ["src/index.ts", "src/jsx-runtime/index.ts"],
  "project": ["src/**/*.ts", "src/**/*.tsx"],
  "ignore": ["test/**", "**/*.test.ts"],
  "ignoreDependencies": [
    "@commitlint/config-conventional",
    "@semantic-release/changelog",
    "@semantic-release/git",
    "@semantic-release/github",
    "@semantic-release/npm",
    "cz-conventional-changelog"
  ]
}
```

### commitlint.config.js

```javascript
// THIS FILE IS AUTO GENERATED: DO NOT EDIT THIS FILE
// Generated based on project structure

export default {
  extends: ["@commitlint/config-conventional"],
  rules: {
    "scope-enum": [
      2,
      "always",
      [
        "core",
        "components",
        "jsx-runtime",
        "services",
        "types",
        "utils",
        "test",
        "ci",
        "docs",
        "deps",
      ],
    ],
    "type-enum": [
      2,
      "always",
      ["feat", "fix", "docs", "test", "refactor", "chore", "ci", "style", "build", "perf", "revert"],
    ],
    "subject-case": [2, "never", ["sentence-case", "start-case", "pascal-case", "upper-case"]],
    "header-max-length": [2, "always", 100],
    "body-leading-blank": [2, "always"],
    "body-max-line-length": [2, "always", 100],
    "footer-leading-blank": [2, "always"],
    "footer-max-line-length": [2, "always", 100],
    "scope-case": [2, "always", "lower-case"],
    "type-case": [2, "always", "lower-case"],
  },
};
```

### .releaserc

```json
{
  "branches": ["master", "main"],
  "plugins": [
    "@semantic-release/commit-analyzer",
    "@semantic-release/release-notes-generator",
    "@semantic-release/changelog",
    [
      "@semantic-release/npm",
      {
        "npmPublish": true
      }
    ],
    [
      "@semantic-release/git",
      {
        "assets": ["package.json", "package-lock.json", "CHANGELOG.md"],
        "message": "chore(release): ${nextRelease.version} [skip ci]"
      }
    ],
    "@semantic-release/github"
  ]
}
```

### .github/workflows/ci.yml

```yaml
name: CI

on:
  push:
    branches: [master, main]
  pull_request:
    branches: [master, main]

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  lint:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: npm
      - run: npm ci
      - run: npm run lint

  test:
    needs: lint
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node-version: [20, 22]
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
          cache: npm
      - run: npm ci
      - run: npm run build
      - run: npm test

  coverage:
    needs: [lint, test]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: npm
      - run: npm ci
      - run: npm run build
      - run: npm run test:coverage
      - uses: coverallsapp/github-action@v2
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}

  release:
    needs: [lint, test, coverage]
    if: github.event_name == 'push' && (github.ref == 'refs/heads/master' || github.ref == 'refs/heads/main')
    runs-on: ubuntu-latest
    permissions:
      contents: write
      issues: write
      pull-requests: write
      id-token: write
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: npm
      - run: npm ci
      - run: npm run build
      - run: npx semantic-release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}
```

### .gitignore

```
# Dependencies
node_modules/

# Build output
dist/

# Coverage
coverage/

# Temporary files
tmp/
*.log

# Environment
.env
.env.*

# IDE
.idea/
.vscode/
*.swp
.DS_Store

# Package archives
*.tgz
```

### Husky Hooks

**.husky/commit-msg:**
```bash
npx --no-install commitlint --edit "$1"
```

**.husky/prepare-commit-msg:**
```bash
exec < /dev/tty && npx cz --hook || true
```

**.husky/pre-push:**
```bash
npm run lint
npm run test:coverage
```

---

## Usage Examples

### Environment Configuration

```typescript
import { render, createEnvironment } from "pupt-lib";

// Create environment optimized for Claude
const claudeEnv = createEnvironment("claude", {
  code: {
    language: "typescript",
    framework: "react",
  },
});

// Render with Claude-optimized output (uses XML tags)
const claudePrompt = render(element, { env: claudeEnv });

// Create environment for GPT (uses markdown headers)
const gptEnv = createEnvironment("gpt");
const gptPrompt = render(element, { env: gptEnv });

// Custom environment with extensions
const customEnv = createEnvironment("claude", {
  code: { language: "python", framework: "django" },
  extensions: {
    companyStyle: "formal",
    maxResponseLength: 500,
  },
});
```

### Basic Prompt

```tsx
// prompts/code-review.tsx
import { Role, Task, Context, SuccessCriteria, Ask } from "pupt-lib";

export default (
  <>
    <Role>
      You are a senior software engineer conducting a code review.
    </Role>

    <Context>
      The code is part of a {<Ask.Text name="projectType" label="Project type" />} project.
    </Context>

    <Task>
      Review the following code and provide constructive feedback:

      <Ask.Editor
        name="code"
        label="Paste the code to review"
        language="typescript"
        required
      />
    </Task>

    <SuccessCriteria>
      <Criterion>Identify any bugs or logical errors</Criterion>
      <Criterion>Suggest performance improvements</Criterion>
      <Criterion>Note any security concerns</Criterion>
      <Criterion>Recommend code style improvements</Criterion>
    </SuccessCriteria>
  </>
);
```

### Rendered Output

```xml
<role>
You are a senior software engineer conducting a code review.
</role>

<context>
The code is part of a React project.
</context>

<task>
Review the following code and provide constructive feedback:

```typescript
function fetchData() {
  // user's code here
}
```
</task>

<success_criteria>
- Identify any bugs or logical errors
- Suggest performance improvements
- Note any security concerns
- Recommend code style improvements
</success_criteria>
```

### Using the Library

```typescript
import { createPrompt, createInputCollector, createEnvironment } from "pupt-lib";

// Load a prompt template
const element = await createPrompt("./prompts/code-review.tsx");

// Collect inputs using depth-first iteration
const collector = createInputCollector();
const values = await collector.collectAll(element, async (req) => {
  // Your UI-specific input collection
  return await askUser(req);
});

// Render with Claude-optimized environment
const env = createEnvironment("claude", {
  code: { language: "typescript" },
});

const prompt = render(element, { inputs: values, env });
console.log(prompt);
```

### Pre-Supplied Values (Skip User Input)

```typescript
import { render, createEnvironment } from "pupt-lib";

// If you already have all values, skip the iterator
const prompt = render(element, {
  inputs: {
    projectType: "React",
    code: "function fetchData() { ... }",
  },
  env: createEnvironment("claude"),
});
```

---

## Research References

### Prompt Engineering Guides
- [Anthropic Claude Best Practices](https://docs.claude.com/en/docs/build-with-claude/prompt-engineering/claude-4-best-practices)
- [OpenAI Prompt Engineering](https://platform.openai.com/docs/guides/prompt-engineering)
- [Google Gemini Prompting Strategies](https://ai.google.dev/gemini-api/docs/prompting-strategies)
- [Prompt Engineering Guide](https://www.promptingguide.ai/)

### Academic Papers
- [Chain-of-Thought Prompting (arXiv 2201.11903)](https://arxiv.org/abs/2201.11903)
- [Systematic Survey of Prompt Engineering (arXiv 2402.07927)](https://arxiv.org/html/2402.07927v2)
- [Survey of Automatic Prompt Engineering (arXiv 2502.11560)](https://arxiv.org/abs/2502.11560)

### Related Libraries
- [mdx-prompt](https://github.com/edspencer/mdx-prompt) - Composable prompts with MDX/React
- [Priompt](https://github.com/anysphere/priompt) - Priority-based JSX prompting
- [@vscode/prompt-tsx](https://www.npmjs.com/package/@vscode/prompt-tsx) - VS Code Copilot prompts
- [AI.JSX](https://github.com/fixie-ai/ai-jsx) - AI application framework

### Detailed Research
See [prompt-structure-research.md](./prompt-structure-research.md) for comprehensive research on:
- Academic papers on prompt engineering
- Framework comparisons (CO-STAR, RISEN, CRISPE, etc.)
- Component taxonomy with usage frequencies
- Vendor-specific recommendations (Anthropic, OpenAI, Google)
- Advanced techniques (self-critique, chain of verification)

### Component-to-Research Mapping

Components included in this design:

| Component | Primary Research Source | Link |
|-----------|------------------------|------|
| **Core Structural** | | |
| Role/Persona | arXiv Templates Study (28.4% usage) | [arXiv 2504.02052](https://arxiv.org/html/2504.02052v2) |
| Task/Directive | arXiv Templates Study (86.7% usage) | [arXiv 2504.02052](https://arxiv.org/html/2504.02052v2) |
| Context | arXiv Templates Study (56.2% usage) | [arXiv 2504.02052](https://arxiv.org/html/2504.02052v2) |
| Audience | CO-STAR Framework | [Parloa Frameworks](https://www.parloa.com/knowledge-hub/prompt-engineering-frameworks/) |
| Tone | CO-STAR, CRISPE Frameworks | [Parloa Frameworks](https://www.parloa.com/knowledge-hub/prompt-engineering-frameworks/) |
| Constraint | arXiv Templates Study (35.7% usage) | [arXiv 2504.02052](https://arxiv.org/html/2504.02052v2) |
| Format | arXiv Templates Study (39.7% usage) | [arXiv 2504.02052](https://arxiv.org/html/2504.02052v2) |
| SuccessCriteria | Anthropic Best Practices | [Claude Docs](https://docs.claude.com/en/docs/build-with-claude/prompt-engineering/claude-4-best-practices) |
| **Examples** | | |
| Example | arXiv Templates Study (19.9% usage) | [arXiv 2504.02052](https://arxiv.org/html/2504.02052v2) |
| **Reasoning** | | |
| Steps | Prompt Report Survey | [arXiv 2406.06608](https://arxiv.org/html/2406.06608v6) |
| **Formatting** | | |
| XML Tags | All Vendors (Anthropic, OpenAI, Google) | [Format Analysis](https://www.robertodiasduarte.com.br/en/markdown-vs-xml-em-prompts-para-llms-uma-analise-comparativa/) |
| Positive Framing | KAIST Research | [Lakera Guide](https://www.lakera.ai/blog/prompt-engineering-guide)

See [Future Work](#future-work) section for additional researched components not included in this design.

---

## Implementation Notes

### Priority Order

Based on research frequency and production importance:

#### Phase 1: Core Foundation
1. **Core JSX Runtime** - Must work first for everything else
2. **Render Function** - Core text generation
3. **Environment Context** - LLM/output configuration
4. **Babel Transformer** - Runtime JSX compilation
5. **Component Registry** - Component registration and lookup
6. **Prompt Component** - Top-level prompt container
7. **Core Structural Components** - Role, Task, Context, Format, Constraint, Section
8. **Ask.* Components** - Text, Editor, Select, MultiSelect, Confirm, File, Number

#### Phase 2: Enhanced Components & Services
9. **InputIterator Service** - Depth-first input collection
10. **Additional Structural Components** (from framework research)
    - Audience (CO-STAR, RISEN)
    - Tone (CO-STAR, CRISPE)
    - SuccessCriteria
11. **Example Components** - Example, Examples
12. **Reasoning Components** - Steps, Step
13. **Data Components** - Data, Code, File
14. **Control Components** - Conditional, Repeat

#### Phase 3: Discovery & Ecosystem
15. **LibraryLoader Service** - Third-party library loading
16. **SearchEngine Service** - Fuzzy prompt search

### Component Research Basis

| Component | Research Source | Usage/Importance |
|-----------|-----------------|------------------|
| Directive/Task | arXiv Templates | 86.7% usage |
| Context | arXiv Templates | 56.2% usage |
| Output Format | arXiv Templates | 39.7% usage |
| Constraints | arXiv Templates | 35.7% usage |
| Role/Persona | arXiv Templates | 28.4% usage |
| Steps/Workflow | arXiv Templates | 27.5% usage |
| Examples | arXiv Templates | 19.9% usage |
| Audience | CO-STAR, RISEN | Framework standard |
| Tone | CO-STAR, CRISPE | Framework standard |

### Testing Strategy

- Unit tests for each component's render output
- Unit tests for JSX runtime functions
- Unit tests for environment-based output variations (XML vs markdown)
- Unit tests for InputIterator depth-first traversal order
- Unit tests for conditional input handling
- Unit tests for ComponentRegistry inheritance and scoping
- Unit tests for SearchEngine fuzzy matching and filtering
- Integration tests for full prompt rendering
- Integration tests for third-party library loading
- Fixture-based tests with expected output comparisons
- Snapshot tests for component output regression

### Documentation

- JSDoc comments on all public APIs
- README with quick start guide
- Separate guide for creating third-party libraries
- Component reference with examples

---

## Browser Compatibility

> **Status:** Open issue. See [Open Issues: Browser Module Loading](#open-issue-browser-module-loading) for current discussion.

Browser compatibility is not yet fully designed. The core question is how libraries resolve their dependency on `pupt-lib` when loaded at runtime in a browser.

---

## Future Work

The following components and features are documented in the research but deferred for future implementation. See [prompt-structure-research.md](./prompt-structure-research.md) for full details on each.

### Production Quality Components

Components for production-grade prompt safety and quality:

| Component | Purpose | Research Source |
|-----------|---------|-----------------|
| `<Uncertainty>` | Permission to say "I don't know" | [Anthropic Best Practices](https://docs.claude.com/en/docs/build-with-claude/prompt-engineering/claude-4-best-practices) |
| `<Guardrails>` | Safety boundaries, prohibited actions | [Datadog LLM Guardrails](https://www.datadoghq.com/blog/llm-guardrails-best-practices/) |
| `<EdgeCase>` | Handling unusual situations | [AUTOMAT Framework](https://dextralabs.com/blog/prompt-engineering-templates/) |
| `<Fallback>` | Default behavior when uncertain | Production templates |
| `<Verification>` | Fact-checking instructions | [Chain of Verification](https://www.analyticsvidhya.com/blog/2024/07/chain-of-verification/) |
| `<SelfCritique>` | Review/reflect on response | [Self-Criticism Research](https://promptengineering.org/llms-learn-humility-how-self-critique-improves-logic-and-reasoning-in-llms-like-chatgpt/) |
| `<FactCheckList>` | List of verifiable claims | [Jules White Patterns](https://arxiv.org/abs/2302.11382) |

### Advanced Structural Components

Additional components based on research:

| Component | Purpose | Research Source |
|-----------|---------|-----------------|
| `<Objective>` | Explicit goal definition (separate from Task) | [CO-STAR, RACE Frameworks](https://www.parloa.com/knowledge-hub/prompt-engineering-frameworks/) |
| `<Style>` | Writing style specification | [CO-STAR Framework](https://www.parloa.com/knowledge-hub/prompt-engineering-frameworks/) |
| `<Scope>` | In/out of scope boundaries | [Jules White Patterns](https://arxiv.org/abs/2302.11382) |
| `<Workflow>` | Multi-step process definition | [arXiv Templates (27.5% usage)](https://arxiv.org/html/2504.02052v2) |
| `<InputData>` | Distinct data-to-process section | [Prompt Report](https://arxiv.org/html/2406.06608v6) |
| `<References>` | Source materials and citations | [Prompt Canvas](https://arxiv.org/html/2412.05127v1) |
| `<Assumptions>` | Explicit assumptions | System prompt guides |

### Advanced Reasoning Components

| Component | Purpose | Research Source |
|-----------|---------|-----------------|
| `<ChainOfThought>` | Explicit CoT instruction | [Wei et al. 2022](https://arxiv.org/abs/2201.11903) |
| `<Decomposition>` | Task breakdown (Tree-of-Thought) | [Prompt Report](https://arxiv.org/html/2406.06608v6) |
| `<NegativeExample>` | Anti-patterns / what NOT to do | [Few-Shot Best Practices](https://www.promptingguide.ai/techniques/fewshot) |

### Framework Composite Components

Pre-built templates following popular frameworks:

| Component | Framework | Research Source |
|-----------|-----------|-----------------|
| `<COSTAR>` | CO-STAR (Context, Objective, Style, Tone, Audience, Response) | [Singapore GPT-4 Competition Winner](https://www.parloa.com/knowledge-hub/prompt-engineering-frameworks/) |
| `<RISEN>` | RISEN (Role, Instruction, Structure, Examples, Nuance) | [RISEN Framework](https://medium.com/@tahirbalarabe2/prompt-engineering-made-simple-with-the-risen-framework-038d98319574) |
| `<CRISPE>` | CRISPE (Capacity, Role, Insight, Statement, Personality, Experiment) | [OpenAI Internal Framework](https://sourcingdenis.medium.com/crispe-prompt-engineering-framework-e47eaaf83611) |
| `<RTF>` | RTF (Role, Task, Format) | Basic framework |
| `<Framework>` | Custom framework support | - |

### Implementation Notes for Future Work

When implementing future components:

1. **Guardrails & Quality** - Consider implementing as a separate optional package (`pupt-lib-guardrails`) to keep core library lightweight
2. **Framework Composites** - Can be built entirely from existing primitives; consider providing as examples rather than built-in components
3. **Advanced Reasoning** - ChainOfThought and Decomposition may be less necessary as LLMs improve at reasoning automatically

---

## Resolved Design Issues

This section documents design decisions that were previously open but have now been resolved.

### Browser Module Loading

**Status:** Resolved - Import maps with automatic generation

**Context:** With URL-based module loading, browser compatibility requires solving how libraries resolve their `import { Component } from 'pupt-lib'` statement.

**Solution: Auto-Generated Import Maps**

The `Pupt` class handles browser module loading by generating import maps before loading any modules:

```typescript
// When Pupt.init() is called in a browser:
async function setupBrowserModules(sources: string[]): Promise<void> {
  // 1. Resolve full dependency tree
  const allDeps = await resolveDependencyTree(sources);

  // 2. Generate import map pointing to esm.sh CDN
  const importMap = {
    imports: {
      'pupt-lib': 'https://esm.sh/pupt-lib@1.0.0',
      '@acme/components': 'https://esm.sh/@acme/components@1.0.0',
      // ... all dependencies
    },
  };

  // 3. Inject into document before any dynamic imports
  const script = document.createElement('script');
  script.type = 'importmap';
  script.textContent = JSON.stringify(importMap);
  document.head.appendChild(script);
}
```

**Key Properties:**

| Property | How Achieved |
|----------|--------------|
| **Single copy of pupt-lib** | Import map points all `'pupt-lib'` imports to same URL |
| **Deduplication** | Dependency tree resolved before loading; each module loaded once |
| **No library changes** | Libraries use standard `import { Component } from 'pupt-lib'` |
| **Version control** | Import map specifies exact versions |

**Comparison with Node.js:**

| Environment | Module Resolution | Deduplication |
|-------------|-------------------|---------------|
| **Node.js** | npm + node_modules | npm flat tree |
| **Browser** | Import maps + esm.sh | Pupt generates map |

**CDN Options:**

| CDN | Example URL | Notes |
|-----|-------------|-------|
| esm.sh | `https://esm.sh/@acme/pkg@1.0.0` | Auto-builds npm packages as ESM |
| unpkg | `https://unpkg.com/@acme/pkg@1.0.0/dist/index.js` | Serves npm files directly |
| jsDelivr | `https://cdn.jsdelivr.net/npm/@acme/pkg@1.0.0` | Fast, global CDN |
| Self-hosted | `https://cdn.yourcompany.com/...` | Full control |

**Capability Differences:**

Some components require capabilities not available in browsers:

```typescript
// Package declares capabilities
{
  "pupt": {
    "capabilities": ["filesystem"]
  }
}
```

When loading in browser, Pupt warns about incompatible modules:

```
Warning: @acme/file-utils requires "filesystem" capability which is not available in browsers.
Components from this module may not work correctly.
```

---

### Library Dependency Resolution

**Status:** Resolved

**Context:** Libraries can declare dependencies on other libraries via the metadata `dependencies` field:

```typescript
export default {
  name: 'acme-prompts',
  dependencies: ['@common/utils'],
};
```

**Resolution:**

Dependencies are loaded first so their components are available in the registry. The `Pupt` loader handles this automatically:

```typescript
// When loading acme-prompts:
// 1. Fetch acme-prompts metadata (including dependencies)
// 2. Recursively load @common/utils first (registers UtilHeader, etc.)
// 3. Load acme-prompts (can now use <UtilHeader> in its prompts)
```

**Deduplication:**

The loader tracks what's already loaded to prevent duplicate loading:

```typescript
class ModuleLoader {
  private loaded = new Map<string, LoadedModule>();

  async load(source: string): Promise<LoadedModule> {
    // Already loaded? Return cached
    if (this.loaded.has(source)) {
      return this.loaded.get(source)!;
    }

    // Load dependencies first (recursive, with deduplication)
    const manifest = await this.fetchManifest(source);
    for (const dep of manifest.dependencies ?? []) {
      await this.load(dep);  // Recursive, but deduped
    }

    // Load this module
    const module = await this.doLoad(source);
    this.loaded.set(source, module);
    return module;
  }
}
```

**Works in Both Environments:**
- **Node.js:** npm handles the actual code dependencies; our loader handles component registration order
- **Browser:** Import map includes all dependencies; our loader ensures correct registration order

---

### Component Detection Across Bundles

**Status:** Resolved - Global Symbol + Import Maps

**Context:** If libraries are bundled separately, each has its own copy of the `Component` class. The `instanceof Component` check fails across bundles.

**Solution: Two-Pronged Approach**

1. **Import maps prevent the problem** — In browsers, import maps ensure all libraries use the same pupt-lib instance. No duplicate bundles.

2. **Global Symbol as fallback** — For edge cases where import maps aren't used, `Symbol.for()` enables detection across bundles:

```typescript
// pupt-lib/src/component.ts
const COMPONENT_MARKER = Symbol.for('pupt-lib:component:v1');

export abstract class Component<Props = {}> {
  static [COMPONENT_MARKER] = true;

  abstract render(props: Props, context: RenderContext): PuptNode;
}

export function isComponentClass(value: unknown): value is typeof Component {
  return (
    typeof value === 'function' &&
    value[Symbol.for('pupt-lib:component:v1')] === true
  );
}
```

**Why This Works:**

| Scenario | Detection Method |
|----------|------------------|
| Single pupt-lib instance (normal) | `instanceof Component` works |
| Multiple pupt-lib instances (edge case) | `Symbol.for()` still works |
| Libraries from different bundles | `Symbol.for()` is globally shared |

**Implementation:**

```typescript
// Component auto-discovery in module loader
function discoverComponents(moduleExports: Record<string, unknown>) {
  const components: Record<string, ComponentClass> = {};

  for (const [name, value] of Object.entries(moduleExports)) {
    if (isComponentClass(value)) {
      components[name] = value;
    }
  }

  return components;
}
```
